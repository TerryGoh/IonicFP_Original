import { EventEmitter, ElementRef, OnInit, OnChanges, OnDestroy, AfterViewInit, NgZone, ChangeDetectorRef } from '@angular/core';
import { CanvasWhiteboardUpdate } from './canvas-whiteboard-update.model';
import { CanvasWhiteboardService } from './canvas-whiteboard.service';
import { CanvasWhiteboardOptions } from './canvas-whiteboard-options';
import { CanvasWhiteboardShape } from './shapes/canvas-whiteboard-shape';
import { CanvasWhiteboardShapeService, INewCanvasWhiteboardShape } from './shapes/canvas-whiteboard-shape.service';
import { CanvasWhiteboardShapeOptions } from './shapes/canvas-whiteboard-shape-options';
import * as ɵngcc0 from '@angular/core';
export declare class CanvasWhiteboardComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {
    private ngZone;
    private changeDetectorRef;
    private canvasWhiteboardService;
    private canvasWhiteboardShapeService;
    options: CanvasWhiteboardOptions;
    batchUpdateTimeoutDuration: number;
    private _imageUrl;
    set imageUrl(imageUrl: string);
    get imageUrl(): string;
    aspectRatio: number;
    drawButtonClass: string;
    clearButtonClass: string;
    undoButtonClass: string;
    redoButtonClass: string;
    saveDataButtonClass: string;
    drawButtonText: string;
    clearButtonText: string;
    undoButtonText: string;
    redoButtonText: string;
    saveDataButtonText: string;
    strokeColorPickerText: string;
    fillColorPickerText: string;
    drawButtonEnabled: boolean;
    clearButtonEnabled: boolean;
    undoButtonEnabled: boolean;
    redoButtonEnabled: boolean;
    saveDataButtonEnabled: boolean;
    shouldDownloadDrawing: boolean;
    /** @deprecated. Replaced with strokeColorPickerEnabled and fillColorPickerEnabled inputs */
    colorPickerEnabled: boolean;
    strokeColorPickerEnabled: boolean;
    fillColorPickerEnabled: boolean;
    lineWidth: number;
    strokeColor: string;
    startingColor: string;
    scaleFactor: number;
    drawingEnabled: boolean;
    showStrokeColorPicker: boolean;
    showFillColorPicker: boolean;
    downloadedFileName: string;
    lineJoin: string;
    lineCap: string;
    shapeSelectorEnabled: boolean;
    showShapeSelector: boolean;
    fillColor: string;
    onClear: EventEmitter<any>;
    onUndo: EventEmitter<any>;
    onRedo: EventEmitter<any>;
    onBatchUpdate: EventEmitter<CanvasWhiteboardUpdate[]>;
    onImageLoaded: EventEmitter<any>;
    onSave: EventEmitter<string | Blob>;
    canvas: ElementRef;
    context: CanvasRenderingContext2D;
    private _incompleteShapesCanvas;
    private _incompleteShapesCanvasContext;
    private _incompleteShapesMap;
    private _imageElement;
    private _canDraw;
    private _clientDragging;
    private _updateHistory;
    private _lastUUID;
    private _shapesMap;
    private _undoStack;
    private _redoStack;
    private _batchUpdates;
    private _updatesNotDrawn;
    private _updateTimeout;
    private _canvasWhiteboardServiceSubscriptions;
    private _resizeSubscription;
    private _registeredShapesSubscription;
    selectedShapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;
    canvasWhiteboardShapePreviewOptions: CanvasWhiteboardShapeOptions;
    constructor(ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, canvasWhiteboardService: CanvasWhiteboardService, canvasWhiteboardShapeService: CanvasWhiteboardShapeService);
    /**
     * Initialize the canvas drawing context. If we have an aspect ratio set up, the canvas will resize
     * according to the aspect ratio.
     */
    ngOnInit(): void;
    /**
     * If an image exists and it's url changes, we need to redraw the new image on the canvas.
     */
    ngOnChanges(changes: any): void;
    /**
     * Recalculate the width and height of the canvas after the view has been fully initialized
     */
    ngAfterViewInit(): void;
    /**
     * This method reads the options which are helpful since they can be really long when specified in HTML
     * This method is also called everytime the options object changes
     * For security reasons we must check each item on its own since if we iterate the keys
     * we may be injected with malicious values
     *
     * @param options
     */
    private _initInputsFromOptions;
    private _isNullOrUndefined;
    /**
     * Init global window listeners like resize and keydown
     */
    private _initCanvasEventListeners;
    /**
     * Subscribes to new signals in the canvas whiteboard service and executes methods accordingly
     * Because of circular publishing and subscribing, the canvas methods do not use the service when
     * local actions are completed (Ex. clicking undo from the button inside this component)
     */
    private _initCanvasServiceObservables;
    /**
     * Calculate the canvas width and height from it's parent container width and height (use aspect ratio if needed)
     */
    private _calculateCanvasWidthAndHeight;
    /**
     * Load an image and draw it on the canvas (if an image exists)
     * @param callbackFn A function that is called after the image loading is finished
     * @return Emits a value when the image has been loaded.
     */
    private _loadImage;
    /**
     * Sends a notification after clearing the canvas
     * This method should only be called from the clear button in this component since it will emit an clear event
     * If the client calls this method he may create a circular clear action which may cause danger.
     */
    clearCanvasLocal(): void;
    /**
     * Clears all content on the canvas.
     */
    clearCanvas(): void;
    /**
     * This method resets the state of the canvas and redraws it.
     * It calls a callback function after redrawing
     * @param callbackFn
     */
    private _removeCanvasData;
    /**
     * Clears the canvas and redraws the image if the url exists.
     * @param callbackFn A function that is called after the background is redrawn
     * @return Emits a value when the clearing is finished
     */
    private _redrawBackground;
    private _drawStartingColor;
    /**
     * @deprecated Use getDrawingEnabled(): boolean
     */
    getShouldDraw(): boolean;
    /**
     * Returns a value of whether the user clicked the draw button on the canvas.
     */
    getDrawingEnabled(): boolean;
    /**
     * Toggles drawing on the canvas. It is called via the draw button on the canvas.
     */
    toggleDrawingEnabled(): void;
    /**
     * Set if drawing is enabled from the client using the canvas
     * @param drawingEnabled
     */
    setDrawingEnabled(drawingEnabled: boolean): void;
    /**
     * @deprecated Please use the changeStrokeColor(newStrokeColor: string): void method
     */
    changeColor(newStrokeColor: string): void;
    /**
     * Replaces the drawing color with a new color
     * The format should be ("#ffffff" or "rgb(r,g,b,a?)")
     * This method is public so that anyone can access the canvas and change the stroke color
     *
     * @param newStrokeColor The new stroke color
     */
    changeStrokeColor(newStrokeColor: string): void;
    /**
     * Replaces the fill color with a new color
     * The format should be ("#ffffff" or "rgb(r,g,b,a?)")
     * This method is public so that anyone can access the canvas and change the fill color
     *
     * @param newFillColor The new fill color
     */
    changeFillColor(newFillColor: string): void;
    /**
     * This method is invoked by the undo button on the canvas screen
     * It calls the global undo method and emits a notification after undoing.
     * This method should only be called from the undo button in this component since it will emit an undo event
     * If the client calls this method he may create a circular undo action which may cause danger.
     */
    undoLocal(): void;
    /**
     * This methods selects the last uuid prepares it for undoing (making the whole update sequence invisible)
     * This method can be called if the canvas component is a ViewChild of some other component.
     * This method will work even if the undo button has been disabled
     */
    undo(callbackFn?: (updateUUID: string) => void): void;
    /**
     * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid invisible
     * @param updateUUID
     */
    private _undoCanvas;
    /**
     * This method is invoked by the redo button on the canvas screen
     * It calls the global redo method and emits a notification after redoing
     * This method should only be called from the redo button in this component since it will emit an redo event
     * If the client calls this method he may create a circular redo action which may cause danger.
     */
    redoLocal(): void;
    /**
     * This methods selects the last uuid prepares it for redoing (making the whole update sequence visible)
     * This method can be called if the canvas component is a ViewChild of some other component.
     * This method will work even if the redo button has been disabled
     */
    redo(callbackFn?: any): void;
    /**
     * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid visible
     * @param updateUUID
     */
    private _redoCanvas;
    /**
     * Catches the Mouse and Touch events made on the canvas.
     * If drawing is disabled (If an image exists but it's not loaded, or the user did not click Draw),
     * this function does nothing.
     *
     * If a "mousedown | touchstart" event is triggered, dragging will be set to true and an CanvasWhiteboardUpdate object
     * of type "start" will be drawn and then sent as an update to all receiving ends.
     *
     * If a "mousemove | touchmove" event is triggered and the client is dragging, an CanvasWhiteboardUpdate object
     * of type "drag" will be drawn and then sent as an update to all receiving ends.
     *
     * If a "mouseup, mouseout | touchend, touchcancel" event is triggered, dragging will be set to false and
     * an CanvasWhiteboardUpdate object of type "stop" will be drawn and then sent as an update to all receiving ends.
     *
     */
    canvasUserEvents(event: any): void;
    /**
     * Get the coordinates (x,y) from a given event
     * If it is a touch event, get the touch positions
     * If we released the touch, the position will be placed in the changedTouches object
     * If it is not a touch event, use the original mouse event received
     * @param eventData
     */
    private _getCanvasEventPosition;
    /**
     * The update coordinates on the canvas are mapped so that all receiving ends
     * can reverse the mapping and get the same position as the one that
     * was drawn on this update.
     *
     * @param update The CanvasWhiteboardUpdate object.
     */
    private _prepareToSendUpdate;
    /**
     * Catches the Key Up events made on the canvas.
     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 90 (z), an undo action will be performed
     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 89 (y), a redo action will be performed
     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 83 (s) or 115(S), a save action will be performed
     *
     * @param event The event that occurred.
     */
    private _canvasKeyDown;
    /**
     * On window resize, recalculate the canvas dimensions and redraw the history
     */
    private _redrawCanvasOnResize;
    /**
     * Redraw the saved history after resetting the canvas state
     */
    private _redrawHistory;
    /**
     * Draws a CanvasWhiteboardUpdate object on the canvas.
     * The coordinates are first reverse mapped so that they can be drawn in the proper place. The update
     * is afterwards added to the undoStack so that it can be
     *
     * If the CanvasWhiteboardUpdate Type is "start", a new "selectedShape" is created.
     * If the CanvasWhiteboardUpdate Type is "drag", the shape is taken from the shapesMap and then it's updated.
     * Afterwards the context is used to draw the shape on the canvas.
     * This function saves the last X and Y coordinates that were drawn.
     *
     * @param update The update object.
     */
    private _draw;
    private _drawIncompleteShapes;
    private _swapCompletedShapeToActualCanvas;
    private _resetIncompleteShapeCanvas;
    /**
     * Delete everything from the screen, redraw the background, and then redraw all the shapes from the shapesMap
     */
    drawAllShapes(): void;
    private _addCurrentShapeDataToAnUpdate;
    generateShapePreviewOptions(): CanvasWhiteboardShapeOptions;
    /**
     * Sends the update to all receiving ends as an Event emit. This is done as a batch operation (meaning
     * multiple updates are sent at the same time). If this method is called, after 100 ms all updates
     * that were made at that time will be packed up together and sent to the receiver.
     *
     * @param update The update object.
     * @return Emits an Array of Updates when the batch.
     */
    private _prepareUpdateForBatchDispatch;
    /**
     * Draws an Array of Updates on the canvas.
     *
     * @param updates The array with Updates.
     */
    drawUpdates(updates: CanvasWhiteboardUpdate[]): void;
    /**
     * Draw any missing updates that were received before the image was loaded
     */
    private _drawMissingUpdates;
    /**
     * Draws an image on the canvas
     *
     * @param context The context used to draw the image on the canvas.
     * @param image The image to draw.
     * @param x The X coordinate for the starting draw position.
     * @param y The Y coordinate for the starting draw position.
     * @param width The width of the image that will be drawn.
     * @param height The height of the image that will be drawn.
     * @param offsetX The offsetX if the image size is larger than the canvas (aspect Ratio)
     * @param offsetY The offsetY if the image size is larger than the canvas (aspect Ratio)
     */
    private _drawImage;
    /**
     * The HTMLCanvasElement.toDataURL() method returns a data URI containing a representation of the image in the format specified by the type parameter (defaults to PNG).
     * The returned image is in a resolution of 96 dpi.
     * If the height or width of the canvas is 0, the string "data:," is returned.
     * If the requested type is not image/png, but the returned value starts with data:image/png, then the requested type is not supported.
     * Chrome also supports the image/webp type.
     *
     * @param returnedDataType A DOMString indicating the image format. The default format type is image/png.
     * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.
     If this argument is anything else, the default value for image quality is used. The default value is 0.92. Other arguments are ignored.
     */
    generateCanvasDataUrl(returnedDataType?: string, returnedDataQuality?: number): string;
    /**
     * Generate a Blob object representing the content drawn on the canvas.
     * This file may be cached on the disk or stored in memory at the discretion of the user agent.
     * If type is not specified, the image type is image/png. The created image is in a resolution of 96dpi.
     * The third argument is used with image/jpeg images to specify the quality of the output.
     *
     * @param callbackFn The function that should be executed when the blob is created. Should accept a parameter Blob (for the result).
     * @param returnedDataType A DOMString indicating the image format. The default type is image/png.
     * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.
     If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
     */
    generateCanvasBlob(callbackFn: any, returnedDataType?: string, returnedDataQuality?: number): void;
    /**
     * Generate a canvas image representation and download it locally
     * The name of the image is canvas_drawing_ + the current local Date and Time the image was created
     * Methods for standalone creation of the images in this method are left here for backwards compatibility
     *
     * @param returnedDataType A DOMString indicating the image format. The default type is image/png.
     * @param downloadData? The created string or Blob (IE).
     * @param customFileName? The name of the file that should be downloaded
     */
    downloadCanvasImage(returnedDataType?: string, downloadData?: string | Blob, customFileName?: string): void;
    /**
     * Save the canvas blob (IE) locally
     * @param blob
     * @param returnedDataType
     */
    private _saveCanvasBlob;
    /**
     * This method generates a canvas url string or a canvas blob with the presented data type
     * A callback function is then invoked since the blob creation must be done via a callback
     *
     * @param callback
     * @param returnedDataType
     * @param returnedDataQuality
     */
    generateCanvasData(callback: any, returnedDataType?: string, returnedDataQuality?: number): void;
    /**
     * Local method to invoke saving of the canvas data when clicked on the canvas Save button
     * This method will emit the generated data with the specified Event Emitter
     *
     * @param returnedDataType
     */
    saveLocal(returnedDataType?: string): void;
    private _generateDataTypeString;
    /**
     * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.
     * If no value is supplied (null/undefined) the current value will be negated and used.
     * @param value
     */
    toggleStrokeColorPicker(value: boolean): void;
    /**
     * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.
     * If no value is supplied (null/undefined) the current value will be negated and used.
     * @param value
     */
    toggleFillColorPicker(value: boolean): void;
    /**
     * Toggles the shape selector window, delegating the showShapeSelector Input to the CanvasWhiteboardShapeSelectorComponent.
     * If no value is supplied (null/undefined) the current value will be negated and used.
     * @param value
     */
    toggleShapeSelector(value: boolean): void;
    selectShape(newShapeBlueprint: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): void;
    /**
     * Returns a deep copy of the current drawing history for the canvas.
     * The deep copy is returned because we don't want anyone to mutate the current history
     */
    getDrawingHistory(): CanvasWhiteboardUpdate[];
    /**
     * Unsubscribe from a given subscription if it is active
     * @param subscription
     */
    private _unsubscribe;
    private _generateUUID;
    private _random4;
    /**
     * Unsubscribe from the service observables
     */
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CanvasWhiteboardComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CanvasWhiteboardComponent, "canvas-whiteboard", never, { "batchUpdateTimeoutDuration": "batchUpdateTimeoutDuration"; "drawButtonText": "drawButtonText"; "clearButtonText": "clearButtonText"; "undoButtonText": "undoButtonText"; "redoButtonText": "redoButtonText"; "saveDataButtonText": "saveDataButtonText"; "strokeColorPickerText": "strokeColorPickerText"; "fillColorPickerText": "fillColorPickerText"; "drawButtonEnabled": "drawButtonEnabled"; "clearButtonEnabled": "clearButtonEnabled"; "undoButtonEnabled": "undoButtonEnabled"; "redoButtonEnabled": "redoButtonEnabled"; "saveDataButtonEnabled": "saveDataButtonEnabled"; "shouldDownloadDrawing": "shouldDownloadDrawing"; "colorPickerEnabled": "colorPickerEnabled"; "strokeColorPickerEnabled": "strokeColorPickerEnabled"; "fillColorPickerEnabled": "fillColorPickerEnabled"; "lineWidth": "lineWidth"; "strokeColor": "strokeColor"; "startingColor": "startingColor"; "scaleFactor": "scaleFactor"; "drawingEnabled": "drawingEnabled"; "showStrokeColorPicker": "showStrokeColorPicker"; "showFillColorPicker": "showFillColorPicker"; "lineJoin": "lineJoin"; "lineCap": "lineCap"; "shapeSelectorEnabled": "shapeSelectorEnabled"; "showShapeSelector": "showShapeSelector"; "fillColor": "fillColor"; "imageUrl": "imageUrl"; "aspectRatio": "aspectRatio"; "drawButtonClass": "drawButtonClass"; "clearButtonClass": "clearButtonClass"; "undoButtonClass": "undoButtonClass"; "redoButtonClass": "redoButtonClass"; "saveDataButtonClass": "saveDataButtonClass"; "downloadedFileName": "downloadedFileName"; "options": "options"; }, { "onClear": "onClear"; "onUndo": "onUndo"; "onRedo": "onRedo"; "onBatchUpdate": "onBatchUpdate"; "onImageLoaded": "onImageLoaded"; "onSave": "onSave"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzLXdoaXRlYm9hcmQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNhbnZhcy13aGl0ZWJvYXJkLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQsIE5nWm9uZSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENhbnZhc1doaXRlYm9hcmRVcGRhdGUgfSBmcm9tICcuL2NhbnZhcy13aGl0ZWJvYXJkLXVwZGF0ZS5tb2RlbCc7XG5pbXBvcnQgeyBDYW52YXNXaGl0ZWJvYXJkU2VydmljZSB9IGZyb20gJy4vY2FudmFzLXdoaXRlYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBDYW52YXNXaGl0ZWJvYXJkT3B0aW9ucyB9IGZyb20gJy4vY2FudmFzLXdoaXRlYm9hcmQtb3B0aW9ucyc7XG5pbXBvcnQgeyBDYW52YXNXaGl0ZWJvYXJkU2hhcGUgfSBmcm9tICcuL3NoYXBlcy9jYW52YXMtd2hpdGVib2FyZC1zaGFwZSc7XG5pbXBvcnQgeyBDYW52YXNXaGl0ZWJvYXJkU2hhcGVTZXJ2aWNlLCBJTmV3Q2FudmFzV2hpdGVib2FyZFNoYXBlIH0gZnJvbSAnLi9zaGFwZXMvY2FudmFzLXdoaXRlYm9hcmQtc2hhcGUuc2VydmljZSc7XG5pbXBvcnQgeyBDYW52YXNXaGl0ZWJvYXJkU2hhcGVPcHRpb25zIH0gZnJvbSAnLi9zaGFwZXMvY2FudmFzLXdoaXRlYm9hcmQtc2hhcGUtb3B0aW9ucyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDYW52YXNXaGl0ZWJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBuZ1pvbmU7XG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBwcml2YXRlIGNhbnZhc1doaXRlYm9hcmRTZXJ2aWNlO1xuICAgIHByaXZhdGUgY2FudmFzV2hpdGVib2FyZFNoYXBlU2VydmljZTtcbiAgICBvcHRpb25zOiBDYW52YXNXaGl0ZWJvYXJkT3B0aW9ucztcbiAgICBiYXRjaFVwZGF0ZVRpbWVvdXREdXJhdGlvbjogbnVtYmVyO1xuICAgIHByaXZhdGUgX2ltYWdlVXJsO1xuICAgIHNldCBpbWFnZVVybChpbWFnZVVybDogc3RyaW5nKTtcbiAgICBnZXQgaW1hZ2VVcmwoKTogc3RyaW5nO1xuICAgIGFzcGVjdFJhdGlvOiBudW1iZXI7XG4gICAgZHJhd0J1dHRvbkNsYXNzOiBzdHJpbmc7XG4gICAgY2xlYXJCdXR0b25DbGFzczogc3RyaW5nO1xuICAgIHVuZG9CdXR0b25DbGFzczogc3RyaW5nO1xuICAgIHJlZG9CdXR0b25DbGFzczogc3RyaW5nO1xuICAgIHNhdmVEYXRhQnV0dG9uQ2xhc3M6IHN0cmluZztcbiAgICBkcmF3QnV0dG9uVGV4dDogc3RyaW5nO1xuICAgIGNsZWFyQnV0dG9uVGV4dDogc3RyaW5nO1xuICAgIHVuZG9CdXR0b25UZXh0OiBzdHJpbmc7XG4gICAgcmVkb0J1dHRvblRleHQ6IHN0cmluZztcbiAgICBzYXZlRGF0YUJ1dHRvblRleHQ6IHN0cmluZztcbiAgICBzdHJva2VDb2xvclBpY2tlclRleHQ6IHN0cmluZztcbiAgICBmaWxsQ29sb3JQaWNrZXJUZXh0OiBzdHJpbmc7XG4gICAgZHJhd0J1dHRvbkVuYWJsZWQ6IGJvb2xlYW47XG4gICAgY2xlYXJCdXR0b25FbmFibGVkOiBib29sZWFuO1xuICAgIHVuZG9CdXR0b25FbmFibGVkOiBib29sZWFuO1xuICAgIHJlZG9CdXR0b25FbmFibGVkOiBib29sZWFuO1xuICAgIHNhdmVEYXRhQnV0dG9uRW5hYmxlZDogYm9vbGVhbjtcbiAgICBzaG91bGREb3dubG9hZERyYXdpbmc6IGJvb2xlYW47XG4gICAgLyoqIEBkZXByZWNhdGVkLiBSZXBsYWNlZCB3aXRoIHN0cm9rZUNvbG9yUGlja2VyRW5hYmxlZCBhbmQgZmlsbENvbG9yUGlja2VyRW5hYmxlZCBpbnB1dHMgKi9cbiAgICBjb2xvclBpY2tlckVuYWJsZWQ6IGJvb2xlYW47XG4gICAgc3Ryb2tlQ29sb3JQaWNrZXJFbmFibGVkOiBib29sZWFuO1xuICAgIGZpbGxDb2xvclBpY2tlckVuYWJsZWQ6IGJvb2xlYW47XG4gICAgbGluZVdpZHRoOiBudW1iZXI7XG4gICAgc3Ryb2tlQ29sb3I6IHN0cmluZztcbiAgICBzdGFydGluZ0NvbG9yOiBzdHJpbmc7XG4gICAgc2NhbGVGYWN0b3I6IG51bWJlcjtcbiAgICBkcmF3aW5nRW5hYmxlZDogYm9vbGVhbjtcbiAgICBzaG93U3Ryb2tlQ29sb3JQaWNrZXI6IGJvb2xlYW47XG4gICAgc2hvd0ZpbGxDb2xvclBpY2tlcjogYm9vbGVhbjtcbiAgICBkb3dubG9hZGVkRmlsZU5hbWU6IHN0cmluZztcbiAgICBsaW5lSm9pbjogc3RyaW5nO1xuICAgIGxpbmVDYXA6IHN0cmluZztcbiAgICBzaGFwZVNlbGVjdG9yRW5hYmxlZDogYm9vbGVhbjtcbiAgICBzaG93U2hhcGVTZWxlY3RvcjogYm9vbGVhbjtcbiAgICBmaWxsQ29sb3I6IHN0cmluZztcbiAgICBvbkNsZWFyOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBvblVuZG86IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIG9uUmVkbzogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgb25CYXRjaFVwZGF0ZTogRXZlbnRFbWl0dGVyPENhbnZhc1doaXRlYm9hcmRVcGRhdGVbXT47XG4gICAgb25JbWFnZUxvYWRlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgb25TYXZlOiBFdmVudEVtaXR0ZXI8c3RyaW5nIHwgQmxvYj47XG4gICAgY2FudmFzOiBFbGVtZW50UmVmO1xuICAgIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICBwcml2YXRlIF9pbmNvbXBsZXRlU2hhcGVzQ2FudmFzO1xuICAgIHByaXZhdGUgX2luY29tcGxldGVTaGFwZXNDYW52YXNDb250ZXh0O1xuICAgIHByaXZhdGUgX2luY29tcGxldGVTaGFwZXNNYXA7XG4gICAgcHJpdmF0ZSBfaW1hZ2VFbGVtZW50O1xuICAgIHByaXZhdGUgX2NhbkRyYXc7XG4gICAgcHJpdmF0ZSBfY2xpZW50RHJhZ2dpbmc7XG4gICAgcHJpdmF0ZSBfdXBkYXRlSGlzdG9yeTtcbiAgICBwcml2YXRlIF9sYXN0VVVJRDtcbiAgICBwcml2YXRlIF9zaGFwZXNNYXA7XG4gICAgcHJpdmF0ZSBfdW5kb1N0YWNrO1xuICAgIHByaXZhdGUgX3JlZG9TdGFjaztcbiAgICBwcml2YXRlIF9iYXRjaFVwZGF0ZXM7XG4gICAgcHJpdmF0ZSBfdXBkYXRlc05vdERyYXduO1xuICAgIHByaXZhdGUgX3VwZGF0ZVRpbWVvdXQ7XG4gICAgcHJpdmF0ZSBfY2FudmFzV2hpdGVib2FyZFNlcnZpY2VTdWJzY3JpcHRpb25zO1xuICAgIHByaXZhdGUgX3Jlc2l6ZVN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9yZWdpc3RlcmVkU2hhcGVzU3Vic2NyaXB0aW9uO1xuICAgIHNlbGVjdGVkU2hhcGVDb25zdHJ1Y3RvcjogSU5ld0NhbnZhc1doaXRlYm9hcmRTaGFwZTxDYW52YXNXaGl0ZWJvYXJkU2hhcGU+O1xuICAgIGNhbnZhc1doaXRlYm9hcmRTaGFwZVByZXZpZXdPcHRpb25zOiBDYW52YXNXaGl0ZWJvYXJkU2hhcGVPcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZTogTmdab25lLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGNhbnZhc1doaXRlYm9hcmRTZXJ2aWNlOiBDYW52YXNXaGl0ZWJvYXJkU2VydmljZSwgY2FudmFzV2hpdGVib2FyZFNoYXBlU2VydmljZTogQ2FudmFzV2hpdGVib2FyZFNoYXBlU2VydmljZSk7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGRyYXdpbmcgY29udGV4dC4gSWYgd2UgaGF2ZSBhbiBhc3BlY3QgcmF0aW8gc2V0IHVwLCB0aGUgY2FudmFzIHdpbGwgcmVzaXplXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBhc3BlY3QgcmF0aW8uXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBJZiBhbiBpbWFnZSBleGlzdHMgYW5kIGl0J3MgdXJsIGNoYW5nZXMsIHdlIG5lZWQgdG8gcmVkcmF3IHRoZSBuZXcgaW1hZ2Ugb24gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYWZ0ZXIgdGhlIHZpZXcgaGFzIGJlZW4gZnVsbHkgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZWFkcyB0aGUgb3B0aW9ucyB3aGljaCBhcmUgaGVscGZ1bCBzaW5jZSB0aGV5IGNhbiBiZSByZWFsbHkgbG9uZyB3aGVuIHNwZWNpZmllZCBpbiBIVE1MXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBjYWxsZWQgZXZlcnl0aW1lIHRoZSBvcHRpb25zIG9iamVjdCBjaGFuZ2VzXG4gICAgICogRm9yIHNlY3VyaXR5IHJlYXNvbnMgd2UgbXVzdCBjaGVjayBlYWNoIGl0ZW0gb24gaXRzIG93biBzaW5jZSBpZiB3ZSBpdGVyYXRlIHRoZSBrZXlzXG4gICAgICogd2UgbWF5IGJlIGluamVjdGVkIHdpdGggbWFsaWNpb3VzIHZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbml0SW5wdXRzRnJvbU9wdGlvbnM7XG4gICAgcHJpdmF0ZSBfaXNOdWxsT3JVbmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogSW5pdCBnbG9iYWwgd2luZG93IGxpc3RlbmVycyBsaWtlIHJlc2l6ZSBhbmQga2V5ZG93blxuICAgICAqL1xuICAgIHByaXZhdGUgX2luaXRDYW52YXNFdmVudExpc3RlbmVycztcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG5ldyBzaWduYWxzIGluIHRoZSBjYW52YXMgd2hpdGVib2FyZCBzZXJ2aWNlIGFuZCBleGVjdXRlcyBtZXRob2RzIGFjY29yZGluZ2x5XG4gICAgICogQmVjYXVzZSBvZiBjaXJjdWxhciBwdWJsaXNoaW5nIGFuZCBzdWJzY3JpYmluZywgdGhlIGNhbnZhcyBtZXRob2RzIGRvIG5vdCB1c2UgdGhlIHNlcnZpY2Ugd2hlblxuICAgICAqIGxvY2FsIGFjdGlvbnMgYXJlIGNvbXBsZXRlZCAoRXguIGNsaWNraW5nIHVuZG8gZnJvbSB0aGUgYnV0dG9uIGluc2lkZSB0aGlzIGNvbXBvbmVudClcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbml0Q2FudmFzU2VydmljZU9ic2VydmFibGVzO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBpdCdzIHBhcmVudCBjb250YWluZXIgd2lkdGggYW5kIGhlaWdodCAodXNlIGFzcGVjdCByYXRpbyBpZiBuZWVkZWQpXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlQ2FudmFzV2lkdGhBbmRIZWlnaHQ7XG4gICAgLyoqXG4gICAgICogTG9hZCBhbiBpbWFnZSBhbmQgZHJhdyBpdCBvbiB0aGUgY2FudmFzIChpZiBhbiBpbWFnZSBleGlzdHMpXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRm4gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBhZnRlciB0aGUgaW1hZ2UgbG9hZGluZyBpcyBmaW5pc2hlZFxuICAgICAqIEByZXR1cm4gRW1pdHMgYSB2YWx1ZSB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfbG9hZEltYWdlO1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbm90aWZpY2F0aW9uIGFmdGVyIGNsZWFyaW5nIHRoZSBjYW52YXNcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgY2xlYXIgYnV0dG9uIGluIHRoaXMgY29tcG9uZW50IHNpbmNlIGl0IHdpbGwgZW1pdCBhbiBjbGVhciBldmVudFxuICAgICAqIElmIHRoZSBjbGllbnQgY2FsbHMgdGhpcyBtZXRob2QgaGUgbWF5IGNyZWF0ZSBhIGNpcmN1bGFyIGNsZWFyIGFjdGlvbiB3aGljaCBtYXkgY2F1c2UgZGFuZ2VyLlxuICAgICAqL1xuICAgIGNsZWFyQ2FudmFzTG9jYWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRlbnQgb24gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBjbGVhckNhbnZhcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgc3RhdGUgb2YgdGhlIGNhbnZhcyBhbmQgcmVkcmF3cyBpdC5cbiAgICAgKiBJdCBjYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIHJlZHJhd2luZ1xuICAgICAqIEBwYXJhbSBjYWxsYmFja0ZuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcmVtb3ZlQ2FudmFzRGF0YTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgcmVkcmF3cyB0aGUgaW1hZ2UgaWYgdGhlIHVybCBleGlzdHMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRm4gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBhZnRlciB0aGUgYmFja2dyb3VuZCBpcyByZWRyYXduXG4gICAgICogQHJldHVybiBFbWl0cyBhIHZhbHVlIHdoZW4gdGhlIGNsZWFyaW5nIGlzIGZpbmlzaGVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcmVkcmF3QmFja2dyb3VuZDtcbiAgICBwcml2YXRlIF9kcmF3U3RhcnRpbmdDb2xvcjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZ2V0RHJhd2luZ0VuYWJsZWQoKTogYm9vbGVhblxuICAgICAqL1xuICAgIGdldFNob3VsZERyYXcoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmFsdWUgb2Ygd2hldGhlciB0aGUgdXNlciBjbGlja2VkIHRoZSBkcmF3IGJ1dHRvbiBvbiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGdldERyYXdpbmdFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBkcmF3aW5nIG9uIHRoZSBjYW52YXMuIEl0IGlzIGNhbGxlZCB2aWEgdGhlIGRyYXcgYnV0dG9uIG9uIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgdG9nZ2xlRHJhd2luZ0VuYWJsZWQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXQgaWYgZHJhd2luZyBpcyBlbmFibGVkIGZyb20gdGhlIGNsaWVudCB1c2luZyB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGRyYXdpbmdFbmFibGVkXG4gICAgICovXG4gICAgc2V0RHJhd2luZ0VuYWJsZWQoZHJhd2luZ0VuYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgdGhlIGNoYW5nZVN0cm9rZUNvbG9yKG5ld1N0cm9rZUNvbG9yOiBzdHJpbmcpOiB2b2lkIG1ldGhvZFxuICAgICAqL1xuICAgIGNoYW5nZUNvbG9yKG5ld1N0cm9rZUNvbG9yOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBkcmF3aW5nIGNvbG9yIHdpdGggYSBuZXcgY29sb3JcbiAgICAgKiBUaGUgZm9ybWF0IHNob3VsZCBiZSAoXCIjZmZmZmZmXCIgb3IgXCJyZ2IocixnLGIsYT8pXCIpXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHVibGljIHNvIHRoYXQgYW55b25lIGNhbiBhY2Nlc3MgdGhlIGNhbnZhcyBhbmQgY2hhbmdlIHRoZSBzdHJva2UgY29sb3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdTdHJva2VDb2xvciBUaGUgbmV3IHN0cm9rZSBjb2xvclxuICAgICAqL1xuICAgIGNoYW5nZVN0cm9rZUNvbG9yKG5ld1N0cm9rZUNvbG9yOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBmaWxsIGNvbG9yIHdpdGggYSBuZXcgY29sb3JcbiAgICAgKiBUaGUgZm9ybWF0IHNob3VsZCBiZSAoXCIjZmZmZmZmXCIgb3IgXCJyZ2IocixnLGIsYT8pXCIpXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHVibGljIHNvIHRoYXQgYW55b25lIGNhbiBhY2Nlc3MgdGhlIGNhbnZhcyBhbmQgY2hhbmdlIHRoZSBmaWxsIGNvbG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RmlsbENvbG9yIFRoZSBuZXcgZmlsbCBjb2xvclxuICAgICAqL1xuICAgIGNoYW5nZUZpbGxDb2xvcihuZXdGaWxsQ29sb3I6IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBieSB0aGUgdW5kbyBidXR0b24gb24gdGhlIGNhbnZhcyBzY3JlZW5cbiAgICAgKiBJdCBjYWxscyB0aGUgZ2xvYmFsIHVuZG8gbWV0aG9kIGFuZCBlbWl0cyBhIG5vdGlmaWNhdGlvbiBhZnRlciB1bmRvaW5nLlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIHRoZSB1bmRvIGJ1dHRvbiBpbiB0aGlzIGNvbXBvbmVudCBzaW5jZSBpdCB3aWxsIGVtaXQgYW4gdW5kbyBldmVudFxuICAgICAqIElmIHRoZSBjbGllbnQgY2FsbHMgdGhpcyBtZXRob2QgaGUgbWF5IGNyZWF0ZSBhIGNpcmN1bGFyIHVuZG8gYWN0aW9uIHdoaWNoIG1heSBjYXVzZSBkYW5nZXIuXG4gICAgICovXG4gICAgdW5kb0xvY2FsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2RzIHNlbGVjdHMgdGhlIGxhc3QgdXVpZCBwcmVwYXJlcyBpdCBmb3IgdW5kb2luZyAobWFraW5nIHRoZSB3aG9sZSB1cGRhdGUgc2VxdWVuY2UgaW52aXNpYmxlKVxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgaWYgdGhlIGNhbnZhcyBjb21wb25lbnQgaXMgYSBWaWV3Q2hpbGQgb2Ygc29tZSBvdGhlciBjb21wb25lbnQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3b3JrIGV2ZW4gaWYgdGhlIHVuZG8gYnV0dG9uIGhhcyBiZWVuIGRpc2FibGVkXG4gICAgICovXG4gICAgdW5kbyhjYWxsYmFja0ZuPzogKHVwZGF0ZVVVSUQ6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgYW4gVVVJRCBmb3IgYW4gdXBkYXRlLCBhbmQgcmVkcmF3cyB0aGUgY2FudmFzIGJ5IG1ha2luZyBhbGwgdXBkYXRlcyB3aXRoIHRoYXQgdXVpZCBpbnZpc2libGVcbiAgICAgKiBAcGFyYW0gdXBkYXRlVVVJRFxuICAgICAqL1xuICAgIHByaXZhdGUgX3VuZG9DYW52YXM7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBieSB0aGUgcmVkbyBidXR0b24gb24gdGhlIGNhbnZhcyBzY3JlZW5cbiAgICAgKiBJdCBjYWxscyB0aGUgZ2xvYmFsIHJlZG8gbWV0aG9kIGFuZCBlbWl0cyBhIG5vdGlmaWNhdGlvbiBhZnRlciByZWRvaW5nXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gdGhlIHJlZG8gYnV0dG9uIGluIHRoaXMgY29tcG9uZW50IHNpbmNlIGl0IHdpbGwgZW1pdCBhbiByZWRvIGV2ZW50XG4gICAgICogSWYgdGhlIGNsaWVudCBjYWxscyB0aGlzIG1ldGhvZCBoZSBtYXkgY3JlYXRlIGEgY2lyY3VsYXIgcmVkbyBhY3Rpb24gd2hpY2ggbWF5IGNhdXNlIGRhbmdlci5cbiAgICAgKi9cbiAgICByZWRvTG9jYWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgc2VsZWN0cyB0aGUgbGFzdCB1dWlkIHByZXBhcmVzIGl0IGZvciByZWRvaW5nIChtYWtpbmcgdGhlIHdob2xlIHVwZGF0ZSBzZXF1ZW5jZSB2aXNpYmxlKVxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgaWYgdGhlIGNhbnZhcyBjb21wb25lbnQgaXMgYSBWaWV3Q2hpbGQgb2Ygc29tZSBvdGhlciBjb21wb25lbnQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3b3JrIGV2ZW4gaWYgdGhlIHJlZG8gYnV0dG9uIGhhcyBiZWVuIGRpc2FibGVkXG4gICAgICovXG4gICAgcmVkbyhjYWxsYmFja0ZuPzogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBVVUlEIGZvciBhbiB1cGRhdGUsIGFuZCByZWRyYXdzIHRoZSBjYW52YXMgYnkgbWFraW5nIGFsbCB1cGRhdGVzIHdpdGggdGhhdCB1dWlkIHZpc2libGVcbiAgICAgKiBAcGFyYW0gdXBkYXRlVVVJRFxuICAgICAqL1xuICAgIHByaXZhdGUgX3JlZG9DYW52YXM7XG4gICAgLyoqXG4gICAgICogQ2F0Y2hlcyB0aGUgTW91c2UgYW5kIFRvdWNoIGV2ZW50cyBtYWRlIG9uIHRoZSBjYW52YXMuXG4gICAgICogSWYgZHJhd2luZyBpcyBkaXNhYmxlZCAoSWYgYW4gaW1hZ2UgZXhpc3RzIGJ1dCBpdCdzIG5vdCBsb2FkZWQsIG9yIHRoZSB1c2VyIGRpZCBub3QgY2xpY2sgRHJhdyksXG4gICAgICogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBJZiBhIFwibW91c2Vkb3duIHwgdG91Y2hzdGFydFwiIGV2ZW50IGlzIHRyaWdnZXJlZCwgZHJhZ2dpbmcgd2lsbCBiZSBzZXQgdG8gdHJ1ZSBhbmQgYW4gQ2FudmFzV2hpdGVib2FyZFVwZGF0ZSBvYmplY3RcbiAgICAgKiBvZiB0eXBlIFwic3RhcnRcIiB3aWxsIGJlIGRyYXduIGFuZCB0aGVuIHNlbnQgYXMgYW4gdXBkYXRlIHRvIGFsbCByZWNlaXZpbmcgZW5kcy5cbiAgICAgKlxuICAgICAqIElmIGEgXCJtb3VzZW1vdmUgfCB0b3VjaG1vdmVcIiBldmVudCBpcyB0cmlnZ2VyZWQgYW5kIHRoZSBjbGllbnQgaXMgZHJhZ2dpbmcsIGFuIENhbnZhc1doaXRlYm9hcmRVcGRhdGUgb2JqZWN0XG4gICAgICogb2YgdHlwZSBcImRyYWdcIiB3aWxsIGJlIGRyYXduIGFuZCB0aGVuIHNlbnQgYXMgYW4gdXBkYXRlIHRvIGFsbCByZWNlaXZpbmcgZW5kcy5cbiAgICAgKlxuICAgICAqIElmIGEgXCJtb3VzZXVwLCBtb3VzZW91dCB8IHRvdWNoZW5kLCB0b3VjaGNhbmNlbFwiIGV2ZW50IGlzIHRyaWdnZXJlZCwgZHJhZ2dpbmcgd2lsbCBiZSBzZXQgdG8gZmFsc2UgYW5kXG4gICAgICogYW4gQ2FudmFzV2hpdGVib2FyZFVwZGF0ZSBvYmplY3Qgb2YgdHlwZSBcInN0b3BcIiB3aWxsIGJlIGRyYXduIGFuZCB0aGVuIHNlbnQgYXMgYW4gdXBkYXRlIHRvIGFsbCByZWNlaXZpbmcgZW5kcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGNhbnZhc1VzZXJFdmVudHMoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyAoeCx5KSBmcm9tIGEgZ2l2ZW4gZXZlbnRcbiAgICAgKiBJZiBpdCBpcyBhIHRvdWNoIGV2ZW50LCBnZXQgdGhlIHRvdWNoIHBvc2l0aW9uc1xuICAgICAqIElmIHdlIHJlbGVhc2VkIHRoZSB0b3VjaCwgdGhlIHBvc2l0aW9uIHdpbGwgYmUgcGxhY2VkIGluIHRoZSBjaGFuZ2VkVG91Y2hlcyBvYmplY3RcbiAgICAgKiBJZiBpdCBpcyBub3QgYSB0b3VjaCBldmVudCwgdXNlIHRoZSBvcmlnaW5hbCBtb3VzZSBldmVudCByZWNlaXZlZFxuICAgICAqIEBwYXJhbSBldmVudERhdGFcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRDYW52YXNFdmVudFBvc2l0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoZSB1cGRhdGUgY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcyBhcmUgbWFwcGVkIHNvIHRoYXQgYWxsIHJlY2VpdmluZyBlbmRzXG4gICAgICogY2FuIHJldmVyc2UgdGhlIG1hcHBpbmcgYW5kIGdldCB0aGUgc2FtZSBwb3NpdGlvbiBhcyB0aGUgb25lIHRoYXRcbiAgICAgKiB3YXMgZHJhd24gb24gdGhpcyB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXBkYXRlIFRoZSBDYW52YXNXaGl0ZWJvYXJkVXBkYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9wcmVwYXJlVG9TZW5kVXBkYXRlO1xuICAgIC8qKlxuICAgICAqIENhdGNoZXMgdGhlIEtleSBVcCBldmVudHMgbWFkZSBvbiB0aGUgY2FudmFzLlxuICAgICAqIElmIHRoZSBjdHJsS2V5IG9yIGNvbW1hbmRLZXkobWFjT1MpIHdhcyBoZWxkIGFuZCB0aGUga2V5Q29kZSBpcyA5MCAoeiksIGFuIHVuZG8gYWN0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXG4gICAgICogSWYgdGhlIGN0cmxLZXkgb3IgY29tbWFuZEtleShtYWNPUykgd2FzIGhlbGQgYW5kIHRoZSBrZXlDb2RlIGlzIDg5ICh5KSwgYSByZWRvIGFjdGlvbiB3aWxsIGJlIHBlcmZvcm1lZFxuICAgICAqIElmIHRoZSBjdHJsS2V5IG9yIGNvbW1hbmRLZXkobWFjT1MpIHdhcyBoZWxkIGFuZCB0aGUga2V5Q29kZSBpcyA4MyAocykgb3IgMTE1KFMpLCBhIHNhdmUgYWN0aW9uIHdpbGwgYmUgcGVyZm9ybWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgb2NjdXJyZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2FudmFzS2V5RG93bjtcbiAgICAvKipcbiAgICAgKiBPbiB3aW5kb3cgcmVzaXplLCByZWNhbGN1bGF0ZSB0aGUgY2FudmFzIGRpbWVuc2lvbnMgYW5kIHJlZHJhdyB0aGUgaGlzdG9yeVxuICAgICAqL1xuICAgIHByaXZhdGUgX3JlZHJhd0NhbnZhc09uUmVzaXplO1xuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgc2F2ZWQgaGlzdG9yeSBhZnRlciByZXNldHRpbmcgdGhlIGNhbnZhcyBzdGF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgX3JlZHJhd0hpc3Rvcnk7XG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBDYW52YXNXaGl0ZWJvYXJkVXBkYXRlIG9iamVjdCBvbiB0aGUgY2FudmFzLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBhcmUgZmlyc3QgcmV2ZXJzZSBtYXBwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBkcmF3biBpbiB0aGUgcHJvcGVyIHBsYWNlLiBUaGUgdXBkYXRlXG4gICAgICogaXMgYWZ0ZXJ3YXJkcyBhZGRlZCB0byB0aGUgdW5kb1N0YWNrIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICpcbiAgICAgKiBJZiB0aGUgQ2FudmFzV2hpdGVib2FyZFVwZGF0ZSBUeXBlIGlzIFwic3RhcnRcIiwgYSBuZXcgXCJzZWxlY3RlZFNoYXBlXCIgaXMgY3JlYXRlZC5cbiAgICAgKiBJZiB0aGUgQ2FudmFzV2hpdGVib2FyZFVwZGF0ZSBUeXBlIGlzIFwiZHJhZ1wiLCB0aGUgc2hhcGUgaXMgdGFrZW4gZnJvbSB0aGUgc2hhcGVzTWFwIGFuZCB0aGVuIGl0J3MgdXBkYXRlZC5cbiAgICAgKiBBZnRlcndhcmRzIHRoZSBjb250ZXh0IGlzIHVzZWQgdG8gZHJhdyB0aGUgc2hhcGUgb24gdGhlIGNhbnZhcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNhdmVzIHRoZSBsYXN0IFggYW5kIFkgY29vcmRpbmF0ZXMgdGhhdCB3ZXJlIGRyYXduLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVwZGF0ZSBUaGUgdXBkYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9kcmF3O1xuICAgIHByaXZhdGUgX2RyYXdJbmNvbXBsZXRlU2hhcGVzO1xuICAgIHByaXZhdGUgX3N3YXBDb21wbGV0ZWRTaGFwZVRvQWN0dWFsQ2FudmFzO1xuICAgIHByaXZhdGUgX3Jlc2V0SW5jb21wbGV0ZVNoYXBlQ2FudmFzO1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBldmVyeXRoaW5nIGZyb20gdGhlIHNjcmVlbiwgcmVkcmF3IHRoZSBiYWNrZ3JvdW5kLCBhbmQgdGhlbiByZWRyYXcgYWxsIHRoZSBzaGFwZXMgZnJvbSB0aGUgc2hhcGVzTWFwXG4gICAgICovXG4gICAgZHJhd0FsbFNoYXBlcygpOiB2b2lkO1xuICAgIHByaXZhdGUgX2FkZEN1cnJlbnRTaGFwZURhdGFUb0FuVXBkYXRlO1xuICAgIGdlbmVyYXRlU2hhcGVQcmV2aWV3T3B0aW9ucygpOiBDYW52YXNXaGl0ZWJvYXJkU2hhcGVPcHRpb25zO1xuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSB1cGRhdGUgdG8gYWxsIHJlY2VpdmluZyBlbmRzIGFzIGFuIEV2ZW50IGVtaXQuIFRoaXMgaXMgZG9uZSBhcyBhIGJhdGNoIG9wZXJhdGlvbiAobWVhbmluZ1xuICAgICAqIG11bHRpcGxlIHVwZGF0ZXMgYXJlIHNlbnQgYXQgdGhlIHNhbWUgdGltZSkuIElmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYWZ0ZXIgMTAwIG1zIGFsbCB1cGRhdGVzXG4gICAgICogdGhhdCB3ZXJlIG1hZGUgYXQgdGhhdCB0aW1lIHdpbGwgYmUgcGFja2VkIHVwIHRvZ2V0aGVyIGFuZCBzZW50IHRvIHRoZSByZWNlaXZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cGRhdGUgVGhlIHVwZGF0ZSBvYmplY3QuXG4gICAgICogQHJldHVybiBFbWl0cyBhbiBBcnJheSBvZiBVcGRhdGVzIHdoZW4gdGhlIGJhdGNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3ByZXBhcmVVcGRhdGVGb3JCYXRjaERpc3BhdGNoO1xuICAgIC8qKlxuICAgICAqIERyYXdzIGFuIEFycmF5IG9mIFVwZGF0ZXMgb24gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cGRhdGVzIFRoZSBhcnJheSB3aXRoIFVwZGF0ZXMuXG4gICAgICovXG4gICAgZHJhd1VwZGF0ZXModXBkYXRlczogQ2FudmFzV2hpdGVib2FyZFVwZGF0ZVtdKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBEcmF3IGFueSBtaXNzaW5nIHVwZGF0ZXMgdGhhdCB3ZXJlIHJlY2VpdmVkIGJlZm9yZSB0aGUgaW1hZ2Ugd2FzIGxvYWRlZFxuICAgICAqL1xuICAgIHByaXZhdGUgX2RyYXdNaXNzaW5nVXBkYXRlcztcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbiBpbWFnZSBvbiB0aGUgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB1c2VkIHRvIGRyYXcgdGhlIGltYWdlIG9uIHRoZSBjYW52YXMuXG4gICAgICogQHBhcmFtIGltYWdlIFRoZSBpbWFnZSB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB4IFRoZSBYIGNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBkcmF3IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB5IFRoZSBZIGNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBkcmF3IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGltYWdlIHRoYXQgd2lsbCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIHRoYXQgd2lsbCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0WCBUaGUgb2Zmc2V0WCBpZiB0aGUgaW1hZ2Ugc2l6ZSBpcyBsYXJnZXIgdGhhbiB0aGUgY2FudmFzIChhc3BlY3QgUmF0aW8pXG4gICAgICogQHBhcmFtIG9mZnNldFkgVGhlIG9mZnNldFkgaWYgdGhlIGltYWdlIHNpemUgaXMgbGFyZ2VyIHRoYW4gdGhlIGNhbnZhcyAoYXNwZWN0IFJhdGlvKVxuICAgICAqL1xuICAgIHByaXZhdGUgX2RyYXdJbWFnZTtcbiAgICAvKipcbiAgICAgKiBUaGUgSFRNTENhbnZhc0VsZW1lbnQudG9EYXRhVVJMKCkgbWV0aG9kIHJldHVybnMgYSBkYXRhIFVSSSBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGltYWdlIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IHRoZSB0eXBlIHBhcmFtZXRlciAoZGVmYXVsdHMgdG8gUE5HKS5cbiAgICAgKiBUaGUgcmV0dXJuZWQgaW1hZ2UgaXMgaW4gYSByZXNvbHV0aW9uIG9mIDk2IGRwaS5cbiAgICAgKiBJZiB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBjYW52YXMgaXMgMCwgdGhlIHN0cmluZyBcImRhdGE6LFwiIGlzIHJldHVybmVkLlxuICAgICAqIElmIHRoZSByZXF1ZXN0ZWQgdHlwZSBpcyBub3QgaW1hZ2UvcG5nLCBidXQgdGhlIHJldHVybmVkIHZhbHVlIHN0YXJ0cyB3aXRoIGRhdGE6aW1hZ2UvcG5nLCB0aGVuIHRoZSByZXF1ZXN0ZWQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqIENocm9tZSBhbHNvIHN1cHBvcnRzIHRoZSBpbWFnZS93ZWJwIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhVHlwZSBBIERPTVN0cmluZyBpbmRpY2F0aW5nIHRoZSBpbWFnZSBmb3JtYXQuIFRoZSBkZWZhdWx0IGZvcm1hdCB0eXBlIGlzIGltYWdlL3BuZy5cbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhUXVhbGl0eSBBIE51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaW5kaWNhdGluZyBpbWFnZSBxdWFsaXR5IGlmIHRoZSByZXF1ZXN0ZWQgdHlwZSBpcyBpbWFnZS9qcGVnIG9yIGltYWdlL3dlYnAuXG4gICAgIElmIHRoaXMgYXJndW1lbnQgaXMgYW55dGhpbmcgZWxzZSwgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGltYWdlIHF1YWxpdHkgaXMgdXNlZC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC45Mi4gT3RoZXIgYXJndW1lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGdlbmVyYXRlQ2FudmFzRGF0YVVybChyZXR1cm5lZERhdGFUeXBlPzogc3RyaW5nLCByZXR1cm5lZERhdGFRdWFsaXR5PzogbnVtYmVyKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgQmxvYiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGRyYXduIG9uIHRoZSBjYW52YXMuXG4gICAgICogVGhpcyBmaWxlIG1heSBiZSBjYWNoZWQgb24gdGhlIGRpc2sgb3Igc3RvcmVkIGluIG1lbW9yeSBhdCB0aGUgZGlzY3JldGlvbiBvZiB0aGUgdXNlciBhZ2VudC5cbiAgICAgKiBJZiB0eXBlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBpbWFnZSB0eXBlIGlzIGltYWdlL3BuZy4gVGhlIGNyZWF0ZWQgaW1hZ2UgaXMgaW4gYSByZXNvbHV0aW9uIG9mIDk2ZHBpLlxuICAgICAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIHdpdGggaW1hZ2UvanBlZyBpbWFnZXMgdG8gc3BlY2lmeSB0aGUgcXVhbGl0eSBvZiB0aGUgb3V0cHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRm4gVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJsb2IgaXMgY3JlYXRlZC4gU2hvdWxkIGFjY2VwdCBhIHBhcmFtZXRlciBCbG9iIChmb3IgdGhlIHJlc3VsdCkuXG4gICAgICogQHBhcmFtIHJldHVybmVkRGF0YVR5cGUgQSBET01TdHJpbmcgaW5kaWNhdGluZyB0aGUgaW1hZ2UgZm9ybWF0LiBUaGUgZGVmYXVsdCB0eXBlIGlzIGltYWdlL3BuZy5cbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhUXVhbGl0eSBBIE51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaW5kaWNhdGluZyBpbWFnZSBxdWFsaXR5IGlmIHRoZSByZXF1ZXN0ZWQgdHlwZSBpcyBpbWFnZS9qcGVnIG9yIGltYWdlL3dlYnAuXG4gICAgIElmIHRoaXMgYXJndW1lbnQgaXMgYW55dGhpbmcgZWxzZSwgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGltYWdlIHF1YWxpdHkgaXMgdXNlZC4gT3RoZXIgYXJndW1lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGdlbmVyYXRlQ2FudmFzQmxvYihjYWxsYmFja0ZuOiBhbnksIHJldHVybmVkRGF0YVR5cGU/OiBzdHJpbmcsIHJldHVybmVkRGF0YVF1YWxpdHk/OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgY2FudmFzIGltYWdlIHJlcHJlc2VudGF0aW9uIGFuZCBkb3dubG9hZCBpdCBsb2NhbGx5XG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGltYWdlIGlzIGNhbnZhc19kcmF3aW5nXyArIHRoZSBjdXJyZW50IGxvY2FsIERhdGUgYW5kIFRpbWUgdGhlIGltYWdlIHdhcyBjcmVhdGVkXG4gICAgICogTWV0aG9kcyBmb3Igc3RhbmRhbG9uZSBjcmVhdGlvbiBvZiB0aGUgaW1hZ2VzIGluIHRoaXMgbWV0aG9kIGFyZSBsZWZ0IGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhVHlwZSBBIERPTVN0cmluZyBpbmRpY2F0aW5nIHRoZSBpbWFnZSBmb3JtYXQuIFRoZSBkZWZhdWx0IHR5cGUgaXMgaW1hZ2UvcG5nLlxuICAgICAqIEBwYXJhbSBkb3dubG9hZERhdGE/IFRoZSBjcmVhdGVkIHN0cmluZyBvciBCbG9iIChJRSkuXG4gICAgICogQHBhcmFtIGN1c3RvbUZpbGVOYW1lPyBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IHNob3VsZCBiZSBkb3dubG9hZGVkXG4gICAgICovXG4gICAgZG93bmxvYWRDYW52YXNJbWFnZShyZXR1cm5lZERhdGFUeXBlPzogc3RyaW5nLCBkb3dubG9hZERhdGE/OiBzdHJpbmcgfCBCbG9iLCBjdXN0b21GaWxlTmFtZT86IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY2FudmFzIGJsb2IgKElFKSBsb2NhbGx5XG4gICAgICogQHBhcmFtIGJsb2JcbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhVHlwZVxuICAgICAqL1xuICAgIHByaXZhdGUgX3NhdmVDYW52YXNCbG9iO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIGNhbnZhcyB1cmwgc3RyaW5nIG9yIGEgY2FudmFzIGJsb2Igd2l0aCB0aGUgcHJlc2VudGVkIGRhdGEgdHlwZVxuICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlbiBpbnZva2VkIHNpbmNlIHRoZSBibG9iIGNyZWF0aW9uIG11c3QgYmUgZG9uZSB2aWEgYSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHJldHVybmVkRGF0YVR5cGVcbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhUXVhbGl0eVxuICAgICAqL1xuICAgIGdlbmVyYXRlQ2FudmFzRGF0YShjYWxsYmFjazogYW55LCByZXR1cm5lZERhdGFUeXBlPzogc3RyaW5nLCByZXR1cm5lZERhdGFRdWFsaXR5PzogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBMb2NhbCBtZXRob2QgdG8gaW52b2tlIHNhdmluZyBvZiB0aGUgY2FudmFzIGRhdGEgd2hlbiBjbGlja2VkIG9uIHRoZSBjYW52YXMgU2F2ZSBidXR0b25cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGVtaXQgdGhlIGdlbmVyYXRlZCBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBFdmVudCBFbWl0dGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0dXJuZWREYXRhVHlwZVxuICAgICAqL1xuICAgIHNhdmVMb2NhbChyZXR1cm5lZERhdGFUeXBlPzogc3RyaW5nKTogdm9pZDtcbiAgICBwcml2YXRlIF9nZW5lcmF0ZURhdGFUeXBlU3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGNvbG9yIHBpY2tlciB3aW5kb3csIGRlbGVnYXRpbmcgdGhlIHNob3dDb2xvclBpY2tlciBJbnB1dCB0byB0aGUgQ29sb3JQaWNrZXJDb21wb25lbnQuXG4gICAgICogSWYgbm8gdmFsdWUgaXMgc3VwcGxpZWQgKG51bGwvdW5kZWZpbmVkKSB0aGUgY3VycmVudCB2YWx1ZSB3aWxsIGJlIG5lZ2F0ZWQgYW5kIHVzZWQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgdG9nZ2xlU3Ryb2tlQ29sb3JQaWNrZXIodmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGNvbG9yIHBpY2tlciB3aW5kb3csIGRlbGVnYXRpbmcgdGhlIHNob3dDb2xvclBpY2tlciBJbnB1dCB0byB0aGUgQ29sb3JQaWNrZXJDb21wb25lbnQuXG4gICAgICogSWYgbm8gdmFsdWUgaXMgc3VwcGxpZWQgKG51bGwvdW5kZWZpbmVkKSB0aGUgY3VycmVudCB2YWx1ZSB3aWxsIGJlIG5lZ2F0ZWQgYW5kIHVzZWQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgdG9nZ2xlRmlsbENvbG9yUGlja2VyKHZhbHVlOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBzaGFwZSBzZWxlY3RvciB3aW5kb3csIGRlbGVnYXRpbmcgdGhlIHNob3dTaGFwZVNlbGVjdG9yIElucHV0IHRvIHRoZSBDYW52YXNXaGl0ZWJvYXJkU2hhcGVTZWxlY3RvckNvbXBvbmVudC5cbiAgICAgKiBJZiBubyB2YWx1ZSBpcyBzdXBwbGllZCAobnVsbC91bmRlZmluZWQpIHRoZSBjdXJyZW50IHZhbHVlIHdpbGwgYmUgbmVnYXRlZCBhbmQgdXNlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICB0b2dnbGVTaGFwZVNlbGVjdG9yKHZhbHVlOiBib29sZWFuKTogdm9pZDtcbiAgICBzZWxlY3RTaGFwZShuZXdTaGFwZUJsdWVwcmludDogSU5ld0NhbnZhc1doaXRlYm9hcmRTaGFwZTxDYW52YXNXaGl0ZWJvYXJkU2hhcGU+KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBjdXJyZW50IGRyYXdpbmcgaGlzdG9yeSBmb3IgdGhlIGNhbnZhcy5cbiAgICAgKiBUaGUgZGVlcCBjb3B5IGlzIHJldHVybmVkIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnlvbmUgdG8gbXV0YXRlIHRoZSBjdXJyZW50IGhpc3RvcnlcbiAgICAgKi9cbiAgICBnZXREcmF3aW5nSGlzdG9yeSgpOiBDYW52YXNXaGl0ZWJvYXJkVXBkYXRlW107XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBhIGdpdmVuIHN1YnNjcmlwdGlvbiBpZiBpdCBpcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdW5zdWJzY3JpYmU7XG4gICAgcHJpdmF0ZSBfZ2VuZXJhdGVVVUlEO1xuICAgIHByaXZhdGUgX3JhbmRvbTQ7XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgc2VydmljZSBvYnNlcnZhYmxlc1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG59XG4iXX0=