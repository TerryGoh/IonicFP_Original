{"version":3,"sources":["../../../projects/ng2-canvas-whiteboard/src/lib/canvas-whiteboard-update.model.ts","../../../projects/ng2-canvas-whiteboard/src/lib/template.ts","../../../projects/ng2-canvas-whiteboard/src/lib/canvas-whiteboard.service.ts","../../../projects/ng2-canvas-whiteboard/src/lib/canvas-whiteboard-point.model.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/canvas-whiteboard-shape-options.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/canvas-whiteboard-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/circle-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/rectangle-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/free-hand-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/smiley-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/star-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/line-shape.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/canvas-whiteboard-shape.service.ts","../../../projects/ng2-canvas-whiteboard/src/lib/canvas-whiteboard.component.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/canvas-whiteboard-shape-selector.component.ts","../../../projects/ng2-canvas-whiteboard/src/lib/canvas-whiteboard-colorpicker.component.ts","../../../projects/ng2-canvas-whiteboard/src/lib/shapes/canvas-whiteboard-shape-preview.component.ts","../../../projects/ng2-canvas-whiteboard/src/lib/ng2-canvas-whiteboard.module.ts"],"names":["CanvasWhiteboardUpdateType","CanvasWhiteboardUpdate","x","y","type","UUID","selectedShape","selectedShapeOptions","this","deserializeJson","json","parsedJson","JSON","parse","e","console","error","prototype","stringify","objectToSerialize","toFixed","uuid","DEFAULT_STYLES","CanvasWhiteboardService","_canvasDrawSubject","Subject","canvasDrawSubject$","asObservable","_canvasClearSubject","canvasClearSubject$","_canvasUndoSubject","canvasUndoSubject$","_canvasRedoSubject","canvasRedoSubject$","drawCanvas","updates","next","clearCanvas","undoCanvas","updateUUD","redoCanvas","Injectable","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","shouldFillShape","fillStyle","strokeStyle","lineWidth","lineJoin","lineCap","CanvasWhiteboardShape","positionPoint","options","CanvasWhiteboardPoint","CanvasWhiteboardShapeOptions","isVisible","onStopReceived","update","CircleShape","radius","_this","_super","call","getShapeName","draw","context","beginPath","arc","Math","PI","assign","stroke","fill","closePath","drawPreview","canvas","width","height","calculateRadius","onUpdateReceived","sqrt","pow","RectangleShape","rect","FreeHandShape","linePositions","moveTo","lineTo","i","length","controlPoint1","controlPoint2","endPoint","bezierCurveTo","linePosition","push","SmileyShape","leftEyeX","rightEyeX","eyesY","eyeSize","StarShape","spikes","rotation","spikeX","spikeY","step","cos","sin","LineShape","endPosition","CanvasWhiteboardShapeService","registeredShapesSubject","BehaviorSubject","registeredShapes$","getShapeConstructorFromShapeName","shapeName","getCurrentRegisteredShapes","find","shape","getValue","isRegisteredShape","indexOf","registerShape","warn","registeredShapes","registerShapes","shapes","concat","filter","unregisterShape","registeredShape","unregisterShapes","CanvasWhiteboardComponent","ngZone","changeDetectorRef","canvasWhiteboardService","canvasWhiteboardShapeService","batchUpdateTimeoutDuration","drawButtonText","clearButtonText","undoButtonText","redoButtonText","saveDataButtonText","strokeColorPickerText","fillColorPickerText","drawButtonEnabled","clearButtonEnabled","undoButtonEnabled","redoButtonEnabled","saveDataButtonEnabled","shouldDownloadDrawing","colorPickerEnabled","strokeColorPickerEnabled","fillColorPickerEnabled","strokeColor","startingColor","scaleFactor","drawingEnabled","showStrokeColorPicker","showFillColorPicker","shapeSelectorEnabled","showShapeSelector","fillColor","onClear","EventEmitter","onUndo","onRedo","onBatchUpdate","onImageLoaded","onSave","_canDraw","_clientDragging","_updateHistory","_undoStack","_redoStack","_batchUpdates","_updatesNotDrawn","_canvasWhiteboardServiceSubscriptions","_shapesMap","Map","_incompleteShapesMap","canvasWhiteboardShapePreviewOptions","generateShapePreviewOptions","defineProperty","_imageUrl","imageUrl","_imageElement","_redrawHistory","ngOnInit","_initInputsFromOptions","_initCanvasEventListeners","_initCanvasServiceObservables","nativeElement","getContext","_incompleteShapesCanvasContext","_incompleteShapesCanvas","ngOnChanges","changes","isEqual","currentValue","previousValue","ngAfterViewInit","_calculateCanvasWidthAndHeight","_isNullOrUndefined","aspectRatio","drawButtonClass","clearButtonClass","undoButtonClass","redoButtonClass","saveDataButtonClass","downloadedFileName","property","runOutsideAngular","_resizeSubscription","fromEvent","window","pipe","debounceTime","distinctUntilChanged","subscribe","run","_redrawCanvasOnResize","addEventListener","_canvasKeyDown","bind","drawUpdates","_undoCanvas","_redoCanvas","_registeredShapesSubscription","selectedShapeConstructor","parentNode","clientWidth","clientHeight","_loadImage","callbackFn","Image","emit","src","clearCanvasLocal","_removeCanvasData","_redrawBackground","save","_drawImage","restore","_drawMissingUpdates","clearRect","_drawStartingColor","previousFillStyle","fillRect","getShouldDraw","getDrawingEnabled","toggleDrawingEnabled","setDrawingEnabled","changeColor","newStrokeColor","changeStrokeColor","detectChanges","changeFillColor","newFillColor","undoLocal","undo","updateUUID","pop","has","get","drawAllShapes","redoLocal","redo","canvasUserEvents","event","updateType","target","preventDefault","eventPosition","_getCanvasEventPosition","_lastUUID","_generateUUID","START","_addCurrentShapeDataToAnUpdate","DRAG","STOP","_draw","_prepareToSendUpdate","eventData","canvasBoundingRect","getBoundingClientRect","hasTouches","touches","changedTouches","scaleWidth","scaleHeight","xPosition","clientX","left","yPosition","clientY","top","_prepareUpdateForBatchDispatch","ctrlKey","metaKey","keyCode","saveLocal","updatesToDraw","forEach","set","_drawIncompleteShapes","delete","_swapCompletedShapeToActualCanvas","_resetIncompleteShapeCanvas","cloneDeep","_updateTimeout","setTimeout","image","offsetX","offsetY","arguments","finalDrawX","finalDrawY","finalDrawWidth","finalDrawHeight","imageWidth","imageHeight","min","newWidth","newHeight","abs","drawImage","generateCanvasDataUrl","returnedDataType","returnedDataQuality","toDataURL","generateCanvasBlob","toBlobMethod","toBlob","msToBlob","callback","blob","downloadCanvasImage","downloadData","customFileName","undefined","navigator","msSaveOrOpenBlob","downloadLink","document","createElement","setAttribute","fileName","Date","valueOf","_generateDataTypeString","body","appendChild","click","removeChild","_saveCanvasBlob","generateCanvasData","generatedData","split","toggleStrokeColorPicker","value","toggleFillColorPicker","toggleShapeSelector","selectShape","newShapeBlueprint","getDrawingHistory","_unsubscribe","subscription","unsubscribe","_random4","floor","random","toString","substring","ngOnDestroy","Component","args","selector","template","NgZone","ChangeDetectorRef","Input","Output","ViewChild","static","CanvasWhiteboardShapeSelectorComponent","elementRef","onToggleShapeSelector","onShapeSelected","closeOnExternalClick","contains","host","(document:mousedown)","(document:touchstart)","ElementRef","CanvasWhiteboardColorPickerComponent","selectedColor","showColorPicker","onToggleColorPicker","onColorSelected","onSecondaryColorSelected","_context","createColorPalette","gradient","createLinearGradient","addColorStop","toggleColorPicker","determineColorFromCanvas","canvasRect","imageData","getImageData","data","selectColor","color","CanvasWhiteboardShapePreviewComponent","drawShapePreview","shapeConstructor","shapeOptions","NgModule","declarations","imports","CommonModule","providers","exports"],"mappings":"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","sourcesContent":["import {CanvasWhiteboardShapeOptions} from \"./shapes/canvas-whiteboard-shape-options\";\n\nexport enum CanvasWhiteboardUpdateType {\n  START = 0,\n  DRAG = 1,\n  STOP = 2\n}\n\nexport class CanvasWhiteboardUpdate {\n  x: number;\n  y: number;\n  type: CanvasWhiteboardUpdateType;\n  UUID: string;\n\n  selectedShape: string;\n  selectedShapeOptions: CanvasWhiteboardShapeOptions;\n\n  static deserializeJson(json: any): CanvasWhiteboardUpdate {\n    let parsedJson;\n    try {\n      parsedJson = JSON.parse(json);\n      return new CanvasWhiteboardUpdate(\n        parsedJson['x'],\n        parsedJson['y'],\n        parsedJson['type'],\n        parsedJson['uuid'],\n        parsedJson['selectedShape'],\n        parsedJson['selectedShapeOptions']);\n    } catch (e) {\n      console.error(\"The canvas whiteboard update is not parseable\");\n      return null;\n    }\n  }\n\n  constructor(x?: number,\n              y?: number,\n              type?: CanvasWhiteboardUpdateType,\n              UUID?: string,\n              selectedShape?: string,\n              selectedShapeOptions?: CanvasWhiteboardShapeOptions) {\n    this.x = x;\n    this.y = y;\n    this.type = type;\n    this.UUID = UUID;\n    this.selectedShape = selectedShape;\n    this.selectedShapeOptions = selectedShapeOptions;\n  }\n\n  stringify(): string {\n    const objectToSerialize = {\n      x: this.x.toFixed(3),\n      y: this.y.toFixed(3),\n      type: this.type,\n      uuid: this.UUID,\n      selectedShape: this.selectedShape\n    };\n\n    if (this.selectedShapeOptions) {\n      objectToSerialize['selectedShapeOptions'] = this.selectedShapeOptions;\n    }\n\n    return JSON.stringify(objectToSerialize);\n  }\n}\n","export const DEFAULT_STYLES = `\n.canvas_whiteboard_button {\n    display: inline-block;\n    outline: 0px;\n    padding-top: 7px;\n    margin-bottom: 0;\n    font-size: 14px;\n    font-weight: 400;\n    line-height: 1.42857143;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: middle;\n    -ms-touch-action: manipulation;\n    touch-action: manipulation;\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    background-image: none;\n    border: 1px solid transparent;\n    border-radius: 4px;\n}\n\n.canvas_whiteboard_buttons {\n    z-index: 3;\n}\n\n@media (max-width: 400px) {\n     .canvas_whiteboard_buttons {\n            position: absolute;\n            z-inde\n            top: 0;\n            width: 100%;\n            text-align: center;\n      }\n}\n\n@media (min-width: 401px) {\n    .canvas_whiteboard_buttons {\n        position: absolute;\n        right: 0%;\n        color: #fff;\n    }\n}\n\n.canvas_whiteboard_buttons {\n    padding: 5px;\n}\n\n.canvas_whiteboard_buttons > button {\n    margin: 5px;\n}\n\n.canvas_whiteboard_button-draw_animated {\n    -webkit-animation: pulsate 1s ease-out;\n    -webkit-animation-iteration-count: infinite;\n}\n\n@-webkit-keyframes pulsate {\n    0% {\n        -webkit-transform: scale(0.1, 0.1);\n        opacity: 0.0;\n    }\n    50% {\n        opacity: 1.0;\n    }\n    100% {\n        -webkit-transform: scale(1.2, 1.2);\n        opacity: 0.0;\n    }\n}\n.canvas_wrapper_div {\n    width: 100%;\n    height: 100%;\n    border: 0.5px solid #e2e2e2;\n}\n\n.canvas_whiteboard_button-clear {\n    padding-top: 5px;\n}\n\n.canvas_whiteboard {\n    position: absolute;\n    z-index: 1;\n}\n\n.incomplete_shapes_canvas_whiteboard {\n    position: absolute;\n    z-index: 2;\n}\n\n`;\n","import { Injectable } from '@angular/core';\nimport { CanvasWhiteboardUpdate } from './canvas-whiteboard-update.model';\nimport { Observable, Subject } from 'rxjs';\n\n@Injectable()\nexport class CanvasWhiteboardService {\n  private _canvasDrawSubject: Subject<CanvasWhiteboardUpdate[]> = new Subject();\n  canvasDrawSubject$: Observable<CanvasWhiteboardUpdate[]> = this._canvasDrawSubject.asObservable();\n\n  private _canvasClearSubject: Subject<any> = new Subject();\n  canvasClearSubject$: Observable<any> = this._canvasClearSubject.asObservable();\n\n  private _canvasUndoSubject: Subject<any> = new Subject();\n  canvasUndoSubject$: Observable<any> = this._canvasUndoSubject.asObservable();\n\n  private _canvasRedoSubject: Subject<any> = new Subject();\n  canvasRedoSubject$: Observable<any> = this._canvasRedoSubject.asObservable();\n\n  public drawCanvas(updates: CanvasWhiteboardUpdate[]): void {\n    this._canvasDrawSubject.next(updates);\n  }\n\n  public clearCanvas(): void {\n    this._canvasClearSubject.next();\n  }\n\n  public undoCanvas(updateUUD: string): void {\n    this._canvasUndoSubject.next(updateUUD);\n  }\n\n  public redoCanvas(updateUUD: string): void {\n    this._canvasRedoSubject.next(updateUUD);\n  }\n}\n","export class CanvasWhiteboardPoint {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export class CanvasWhiteboardShapeOptions {\n  shouldFillShape?: boolean;\n  fillStyle?: string;\n  strokeStyle?: string;\n  lineWidth?: number;\n  lineJoin?: string;\n  lineCap?: string;\n\n  constructor() {\n    this.shouldFillShape = false;\n    this.fillStyle = null;\n    this.strokeStyle = 'rgba(0, 0, 0, 1)';\n    this.lineWidth = 2;\n    this.lineJoin = 'round';\n    this.lineCap = 'round';\n  }\n}\n","import { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport abstract class CanvasWhiteboardShape {\n  isVisible: boolean;\n  protected positionPoint: CanvasWhiteboardPoint;\n  protected options: CanvasWhiteboardShapeOptions;\n\n  protected constructor(positionPoint?: CanvasWhiteboardPoint,\n                        options?: CanvasWhiteboardShapeOptions) {\n    this.positionPoint = positionPoint || new CanvasWhiteboardPoint(0, 0);\n    this.options = options || new CanvasWhiteboardShapeOptions();\n    this.isVisible = true;\n  }\n\n  abstract getShapeName(): string;\n\n  abstract onUpdateReceived(update: CanvasWhiteboardUpdate): void;\n\n  // noinspection TsLint\n  onStopReceived(update: CanvasWhiteboardUpdate): void {\n  }\n\n  abstract draw(context: CanvasRenderingContext2D): void;\n\n  abstract drawPreview(context: CanvasRenderingContext2D): void;\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class CircleShape extends CanvasWhiteboardShape {\n  radius: number;\n\n  constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, radius?: number) {\n    super(positionPoint, options);\n    this.radius = radius || 0;\n  }\n\n  getShapeName(): string {\n    return 'CircleShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    context.beginPath();\n    context.arc(this.positionPoint.x, this.positionPoint.y, this.radius, 0, Math.PI * 2, false);\n\n    Object.assign(context, this.options);\n\n    context.stroke();\n    if (this.options.shouldFillShape) {\n      context.fill();\n    }\n\n    context.closePath();\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n    this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.radius = this.calculateRadius(update.x, update.y);\n  }\n\n  calculateRadius(x: number, y: number): number {\n    return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n  }\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class RectangleShape extends CanvasWhiteboardShape {\n  width: number;\n  height: number;\n\n  constructor(positionPoint?: CanvasWhiteboardPoint,\n              options?: CanvasWhiteboardShapeOptions,\n              width?: number,\n              height?: number) {\n    super(positionPoint, options);\n    this.width = width || 0;\n    this.height = height || 0;\n  }\n\n  getShapeName(): string {\n    return 'RectangleShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    if (!this.width || !this.height) {\n      return;\n    }\n    context.beginPath();\n\n    Object.assign(context, this.options);\n\n    context.rect(this.positionPoint.x, this.positionPoint.y, this.width, this.height);\n\n    context.stroke();\n    if (this.options.shouldFillShape) {\n      context.fill();\n    }\n\n    context.closePath();\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(2, 2);\n    this.width = context.canvas.width - 4;\n    this.height = context.canvas.height - 4;\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.width = update.x - this.positionPoint.x;\n    this.height = update.y - this.positionPoint.y;\n  }\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class FreeHandShape extends CanvasWhiteboardShape {\n  linePositions: CanvasWhiteboardPoint[];\n\n  constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions) {\n    super(positionPoint, options);\n    this.linePositions = [];\n  }\n\n  getShapeName(): string {\n    return 'FreeHandShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    Object.assign(context, this.options);\n\n    context.beginPath();\n    context.moveTo(this.positionPoint.x, this.positionPoint.y);\n    // Draw a dot\n    context.lineTo(this.positionPoint.x + 1, this.positionPoint.y + 1);\n\n    // Normal fastest free hand drawing\n    // this.linePositions.forEach((linePosition) => {\n    //     context.lineTo(linePosition.x, linePosition.y);\n    // });\n\n    // Quadratic curves drawing\n    let i = 0;\n    while (i < this.linePositions.length) {\n      if (this.linePositions.length - i > 2) {\n        const controlPoint1 = this.linePositions[i];\n        const controlPoint2 = this.linePositions[i + 1];\n        const endPoint = this.linePositions[i + 2];\n        context.bezierCurveTo(controlPoint1.x,\n          controlPoint1.y,\n          controlPoint2.x,\n          controlPoint2.y,\n          endPoint.x,\n          endPoint.y);\n        i += 2;\n      } else {\n        const linePosition = this.linePositions[i];\n        context.lineTo(linePosition.x, linePosition.y);\n        i += 1;\n      }\n    }\n\n    context.stroke();\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(2, 2);\n    this.linePositions = [\n      new CanvasWhiteboardPoint(context.canvas.width - 5, context.canvas.height * 0.3),\n      // new CanvasWhiteboardPoint(context.canvas.width * 0.4, context.canvas.height * 0.6),\n      new CanvasWhiteboardPoint(context.canvas.width * 0.2, context.canvas.height * 0.4),\n      new CanvasWhiteboardPoint(context.canvas.width * 0.6, context.canvas.height * 0.8),\n      new CanvasWhiteboardPoint(context.canvas.width, context.canvas.height)\n    ];\n\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.linePositions.push(new CanvasWhiteboardPoint(update.x, update.y));\n  }\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class SmileyShape extends CanvasWhiteboardShape {\n  radius: number;\n\n  constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, radius?: number) {\n    super(positionPoint, options);\n    this.options.shouldFillShape = true;\n    this.options.fillStyle = this.options.fillStyle || 'yellow';\n\n    this.radius = radius || 0;\n  }\n\n  getShapeName(): string {\n    return 'SmileyShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    context.beginPath();\n\n    Object.assign(context, this.options);\n\n    context.arc(this.positionPoint.x, this.positionPoint.y, this.radius, 0, Math.PI * 2, false);\n    context.fill();\n    context.stroke();\n\n    context.beginPath();\n    const leftEyeX = this.positionPoint.x - this.radius * 0.3;\n    const rightEyeX = this.positionPoint.x + this.radius * 0.3;\n    const eyesY = this.positionPoint.y - this.radius * 0.2;\n    const eyeSize = this.radius * 0.1;\n\n    context.arc(leftEyeX, eyesY, eyeSize, 0, 2 * Math.PI, false);\n    context.arc(rightEyeX, eyesY, eyeSize, 0, 2 * Math.PI, false);\n    context.fillStyle = this.options.strokeStyle;\n    context.fill();\n\n    // draw the mouth\n    context.beginPath();\n    context.arc(this.positionPoint.x, this.positionPoint.y, this.radius * 0.7, 0, Math.PI, false);\n    context.stroke();\n\n    context.closePath();\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n    this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.radius = this.calculateRadius(update.x, update.y);\n  }\n\n  calculateRadius(x: number, y: number): number {\n    return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n  }\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class StarShape extends CanvasWhiteboardShape {\n  radius: number;\n  spikes: number;\n\n  constructor(positionPoint?: CanvasWhiteboardPoint,\n              options?: CanvasWhiteboardShapeOptions,\n              radius?: number,\n              spikes?: number) {\n    super(positionPoint, options);\n    this.radius = radius || 0;\n    this.spikes = spikes || 5;\n  }\n\n  getShapeName(): string {\n    return 'StarShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    Object.assign(context, this.options);\n\n    let rotation = Math.PI / 2 * 3;\n    let spikeX = this.positionPoint.x;\n    let spikeY = this.positionPoint.y;\n    const step = Math.PI / this.spikes;\n\n    context.beginPath();\n    context.moveTo(this.positionPoint.x, this.positionPoint.y - this.radius);\n\n    for (let i = 0; i < this.spikes; i++) {\n      spikeX = this.positionPoint.x + Math.cos(rotation) * this.radius;\n      spikeY = this.positionPoint.y + Math.sin(rotation) * this.radius;\n      context.lineTo(spikeX, spikeY);\n      rotation += step;\n\n      spikeX = this.positionPoint.x + Math.cos(rotation) * (this.radius * 0.4);\n      spikeY = this.positionPoint.y + Math.sin(rotation) * (this.radius * 0.4);\n      context.lineTo(spikeX, spikeY);\n      rotation += step;\n      context.stroke();\n    }\n\n    context.lineTo(this.positionPoint.x, this.positionPoint.y - this.radius);\n    context.closePath();\n\n    context.stroke();\n\n    if (this.options.shouldFillShape) {\n      context.fill();\n    }\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n    this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.radius = this.calculateRadius(update.x, update.y);\n  }\n\n  calculateRadius(x: number, y: number): number {\n    return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n  }\n}\n","import { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardUpdate } from '../canvas-whiteboard-update.model';\n\nexport class LineShape extends CanvasWhiteboardShape {\n  endPosition: CanvasWhiteboardPoint;\n\n  constructor(positionPoint?: CanvasWhiteboardPoint,\n              options?: CanvasWhiteboardShapeOptions,\n              endPosition?: CanvasWhiteboardPoint) {\n    super(positionPoint, options);\n    this.endPosition = endPosition || new CanvasWhiteboardPoint(this.positionPoint.x, this.positionPoint.y);\n  }\n\n  getShapeName(): string {\n    return 'LineShape';\n  }\n\n  draw(context: CanvasRenderingContext2D): void {\n    if (!this.endPosition) {\n      return;\n    }\n    context.beginPath();\n    Object.assign(context, this.options);\n\n    context.moveTo(this.positionPoint.x, this.positionPoint.y);\n    context.lineTo(this.endPosition.x, this.endPosition.y);\n\n    context.closePath();\n    context.stroke();\n  }\n\n  drawPreview(context: CanvasRenderingContext2D): void {\n    this.positionPoint = new CanvasWhiteboardPoint(0, 0);\n    this.endPosition = new CanvasWhiteboardPoint(context.canvas.width, context.canvas.height);\n    this.draw(context);\n  }\n\n  onUpdateReceived(update: CanvasWhiteboardUpdate): void {\n    this.endPosition = new CanvasWhiteboardPoint(update.x, update.y);\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CircleShape } from './circle-shape';\nimport { RectangleShape } from './rectangle-shape';\nimport { FreeHandShape } from './free-hand-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { SmileyShape } from './smiley-shape';\nimport { StarShape } from './star-shape';\nimport { LineShape } from './line-shape';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport type INewCanvasWhiteboardShape<T extends CanvasWhiteboardShape> =\n  new(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, ...args: any[]) => T;\n\n@Injectable()\nexport class CanvasWhiteboardShapeService {\n  private registeredShapesSubject: BehaviorSubject<Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>>;\n  public registeredShapes$: Observable<Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>>;\n\n  constructor() {\n    this.registeredShapesSubject = new BehaviorSubject([\n      FreeHandShape,\n      LineShape,\n      RectangleShape,\n      CircleShape,\n      StarShape,\n      SmileyShape\n    ]);\n    this.registeredShapes$ = this.registeredShapesSubject.asObservable();\n  }\n\n  getShapeConstructorFromShapeName(shapeName: string): INewCanvasWhiteboardShape<CanvasWhiteboardShape> {\n    return this.getCurrentRegisteredShapes().find((shape) =>\n      (new shape).getShapeName() === shapeName);\n  }\n\n  getCurrentRegisteredShapes(): Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>> {\n    return this.registeredShapesSubject.getValue();\n  }\n\n  isRegisteredShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): boolean {\n    return this.getCurrentRegisteredShapes().indexOf(shape) !== -1;\n  }\n\n  registerShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): void {\n    if (this.isRegisteredShape(shape)) {\n      console.warn(`You tried to register a shape:${shape}, but is has already been registered.`);\n      return;\n    }\n\n    const registeredShapes = this.getCurrentRegisteredShapes();\n    registeredShapes.push(shape);\n    this.registeredShapesSubject.next(registeredShapes);\n  }\n\n  registerShapes(shapes: Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>): void {\n    this.registeredShapesSubject.next(\n      this.getCurrentRegisteredShapes()\n        .concat(\n          shapes.filter((shape) => {\n            if (this.isRegisteredShape(shape)) {\n              console.warn(`You tried to register a shape:${shape}, but is has already been registered.`);\n              return false;\n            }\n\n            return true;\n          })\n        )\n    );\n  }\n\n  unregisterShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): void {\n    this.registeredShapesSubject.next(\n      this.getCurrentRegisteredShapes().filter(registeredShape => registeredShape !== shape)\n    );\n  }\n\n  unregisterShapes(shapes: Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>): void {\n    this.registeredShapesSubject.next(\n      this.getCurrentRegisteredShapes().filter(shape => shapes.indexOf(shape) === -1)\n    );\n  }\n}\n","import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  ViewChild,\n  ElementRef,\n  OnInit,\n  OnChanges, OnDestroy, AfterViewInit, NgZone, ChangeDetectorRef\n} from '@angular/core';\nimport { CanvasWhiteboardUpdate, CanvasWhiteboardUpdateType } from './canvas-whiteboard-update.model';\nimport { DEFAULT_STYLES } from './template';\nimport { CanvasWhiteboardService } from './canvas-whiteboard.service';\nimport { CanvasWhiteboardOptions } from './canvas-whiteboard-options';\nimport { CanvasWhiteboardShape } from './shapes/canvas-whiteboard-shape';\nimport { CanvasWhiteboardPoint } from './canvas-whiteboard-point.model';\nimport { CanvasWhiteboardShapeService, INewCanvasWhiteboardShape } from './shapes/canvas-whiteboard-shape.service';\nimport { CanvasWhiteboardShapeOptions } from './shapes/canvas-whiteboard-shape-options';\nimport { fromEvent, Subscription } from 'rxjs';\nimport { debounceTime, distinctUntilChanged } from 'rxjs/operators';\nimport { cloneDeep, isEqual } from 'lodash-es';\n\n@Component({\n  selector: 'canvas-whiteboard',\n  template:\n      `\n    <div class=\"canvas_wrapper_div\">\n      <div class=\"canvas_whiteboard_buttons\">\n        <canvas-whiteboard-shape-selector *ngIf=\"shapeSelectorEnabled\"\n                                          [showShapeSelector]=\"showShapeSelector\"\n                                          [selectedShapeConstructor]=\"selectedShapeConstructor\"\n                                          [shapeOptions]=\"generateShapePreviewOptions()\"\n                                          (onToggleShapeSelector)=\"toggleShapeSelector($event)\"\n                                          (onShapeSelected)=\"selectShape($event)\"></canvas-whiteboard-shape-selector>\n\n        <canvas-whiteboard-colorpicker *ngIf=\"colorPickerEnabled || fillColorPickerEnabled\"\n                                       [previewText]=\"fillColorPickerText\"\n                                       [showColorPicker]=\"showFillColorPicker\"\n                                       [selectedColor]=\"fillColor\"\n                                       (onToggleColorPicker)=\"toggleFillColorPicker($event)\"\n                                       (onColorSelected)=\"changeFillColor($event)\">\n        </canvas-whiteboard-colorpicker>\n\n        <canvas-whiteboard-colorpicker *ngIf=\"colorPickerEnabled || strokeColorPickerEnabled\"\n                                       [previewText]=\"strokeColorPickerText\"\n                                       [showColorPicker]=\"showStrokeColorPicker\"\n                                       [selectedColor]=\"strokeColor\"\n                                       (onToggleColorPicker)=\"toggleStrokeColorPicker($event)\"\n                                       (onColorSelected)=\"changeStrokeColor($event)\">\n        </canvas-whiteboard-colorpicker>\n\n\n        <button *ngIf=\"drawButtonEnabled\" (click)=\"toggleDrawingEnabled()\"\n                [class.canvas_whiteboard_button-draw_animated]=\"getDrawingEnabled()\"\n                class=\"canvas_whiteboard_button canvas_whiteboard_button-draw\" type=\"button\">\n          <i [class]=\"drawButtonClass\" aria-hidden=\"true\"></i> {{drawButtonText}}\n        </button>\n\n        <button *ngIf=\"clearButtonEnabled\" (click)=\"clearCanvasLocal()\" type=\"button\"\n                class=\"canvas_whiteboard_button canvas_whiteboard_button-clear\">\n          <i [class]=\"clearButtonClass\" aria-hidden=\"true\"></i> {{clearButtonText}}\n        </button>\n\n        <button *ngIf=\"undoButtonEnabled\" (click)=\"undoLocal()\" type=\"button\"\n                class=\"canvas_whiteboard_button canvas_whiteboard_button-undo\">\n          <i [class]=\"undoButtonClass\" aria-hidden=\"true\"></i> {{undoButtonText}}\n        </button>\n\n        <button *ngIf=\"redoButtonEnabled\" (click)=\"redoLocal()\" type=\"button\"\n                class=\"canvas_whiteboard_button canvas_whiteboard_button-redo\">\n          <i [class]=\"redoButtonClass\" aria-hidden=\"true\"></i> {{redoButtonText}}\n        </button>\n        <button *ngIf=\"saveDataButtonEnabled\" (click)=\"saveLocal()\" type=\"button\"\n                class=\"canvas_whiteboard_button canvas_whiteboard_button-save\">\n          <i [class]=\"saveDataButtonClass\" aria-hidden=\"true\"></i> {{saveDataButtonText}}\n        </button>\n      </div>\n      <canvas #canvas class=\"canvas_whiteboard\"></canvas>\n      <canvas #incompleteShapesCanvas class=\"incomplete_shapes_canvas_whiteboard\"\n              (mousedown)=\"canvasUserEvents($event)\" (mouseup)=\"canvasUserEvents($event)\"\n              (mousemove)=\"canvasUserEvents($event)\" (mouseout)=\"canvasUserEvents($event)\"\n              (touchstart)=\"canvasUserEvents($event)\" (touchmove)=\"canvasUserEvents($event)\"\n              (touchend)=\"canvasUserEvents($event)\" (touchcancel)=\"canvasUserEvents($event)\"></canvas>\n    </div>\n  `,\n  styles: [DEFAULT_STYLES]\n})\nexport class CanvasWhiteboardComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {\n  @Input() options: CanvasWhiteboardOptions;\n\n  // Number of ms to wait before sending out the updates as an array\n  @Input() batchUpdateTimeoutDuration = 100;\n\n  private _imageUrl: string;\n  @Input() set imageUrl(imageUrl: string) {\n    this._imageUrl = imageUrl;\n    this._imageElement = null;\n    this._redrawHistory();\n  }\n\n  get imageUrl(): string {\n    return this._imageUrl;\n  }\n\n  @Input() aspectRatio: number;\n  @Input() drawButtonClass: string;\n  @Input() clearButtonClass: string;\n  @Input() undoButtonClass: string;\n  @Input() redoButtonClass: string;\n  @Input() saveDataButtonClass: string;\n  @Input() drawButtonText = '';\n  @Input() clearButtonText = '';\n  @Input() undoButtonText = '';\n  @Input() redoButtonText = '';\n  @Input() saveDataButtonText = '';\n  @Input() strokeColorPickerText = 'Stroke';\n  @Input() fillColorPickerText = 'Fill';\n  @Input() drawButtonEnabled = true;\n  @Input() clearButtonEnabled = true;\n  @Input() undoButtonEnabled = false;\n  @Input() redoButtonEnabled = false;\n  @Input() saveDataButtonEnabled = false;\n  @Input() shouldDownloadDrawing = true;\n  /** @deprecated. Replaced with strokeColorPickerEnabled and fillColorPickerEnabled inputs */\n  @Input() colorPickerEnabled: boolean = false;\n  @Input() strokeColorPickerEnabled: boolean = false;\n  @Input() fillColorPickerEnabled: boolean = false;\n  @Input() lineWidth = 2;\n  @Input() strokeColor = 'rgba(0, 0, 0, 1)';\n  @Input() startingColor = '#fff';\n  @Input() scaleFactor = 0;\n  @Input() drawingEnabled = false;\n  @Input() showStrokeColorPicker = false;\n  @Input() showFillColorPicker = false;\n  @Input() downloadedFileName: string;\n\n  @Input() lineJoin = 'round';\n  @Input() lineCap = 'round';\n  @Input() shapeSelectorEnabled = true;\n  @Input() showShapeSelector = false;\n  @Input() fillColor = 'rgba(0,0,0,0)';\n\n  @Output() onClear = new EventEmitter<any>();\n  @Output() onUndo = new EventEmitter<any>();\n  @Output() onRedo = new EventEmitter<any>();\n  @Output() onBatchUpdate = new EventEmitter<CanvasWhiteboardUpdate[]>();\n  @Output() onImageLoaded = new EventEmitter<any>();\n  @Output() onSave = new EventEmitter<string | Blob>();\n\n  @ViewChild('canvas', {static: true}) canvas: ElementRef;\n  context: CanvasRenderingContext2D;\n\n  @ViewChild('incompleteShapesCanvas', {static: true}) private _incompleteShapesCanvas: ElementRef;\n  private _incompleteShapesCanvasContext: CanvasRenderingContext2D;\n  private _incompleteShapesMap: Map<string, CanvasWhiteboardShape>;\n\n  private _imageElement: any;\n\n  private _canDraw = true;\n\n  private _clientDragging = false;\n\n  private _updateHistory: CanvasWhiteboardUpdate[] = [];\n  private _lastUUID: string;\n  private _shapesMap: Map<string, CanvasWhiteboardShape>;\n\n  private _undoStack: string[] = []; // Stores the value of start and count for each continuous stroke\n  private _redoStack: string[] = [];\n  private _batchUpdates: CanvasWhiteboardUpdate[] = [];\n  private _updatesNotDrawn: any = [];\n\n  private _updateTimeout: any;\n\n  private _canvasWhiteboardServiceSubscriptions: Subscription[] = [];\n  private _resizeSubscription: Subscription;\n  private _registeredShapesSubscription: Subscription;\n\n  selectedShapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n  canvasWhiteboardShapePreviewOptions: CanvasWhiteboardShapeOptions;\n\n  constructor(private ngZone: NgZone,\n              private changeDetectorRef: ChangeDetectorRef,\n              private canvasWhiteboardService: CanvasWhiteboardService,\n              private canvasWhiteboardShapeService: CanvasWhiteboardShapeService) {\n    this._shapesMap = new Map<string, CanvasWhiteboardShape>();\n    this._incompleteShapesMap = new Map<string, CanvasWhiteboardShape>();\n    this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n  }\n\n  /**\n   * Initialize the canvas drawing context. If we have an aspect ratio set up, the canvas will resize\n   * according to the aspect ratio.\n   */\n  ngOnInit(): void {\n    this._initInputsFromOptions(this.options);\n    this._initCanvasEventListeners();\n    this._initCanvasServiceObservables();\n    this.context = this.canvas.nativeElement.getContext('2d');\n    this._incompleteShapesCanvasContext = this._incompleteShapesCanvas.nativeElement.getContext('2d');\n  }\n\n  /**\n   * If an image exists and it's url changes, we need to redraw the new image on the canvas.\n   */\n  ngOnChanges(changes: any): void {\n    if (changes.options && !isEqual(changes.options.currentValue, changes.options.previousValue)) {\n      this._initInputsFromOptions(changes.options.currentValue);\n    }\n  }\n\n  /**\n   * Recalculate the width and height of the canvas after the view has been fully initialized\n   */\n  ngAfterViewInit(): void {\n    this._calculateCanvasWidthAndHeight();\n    this._redrawHistory();\n  }\n\n  /**\n   * This method reads the options which are helpful since they can be really long when specified in HTML\n   * This method is also called everytime the options object changes\n   * For security reasons we must check each item on its own since if we iterate the keys\n   * we may be injected with malicious values\n   *\n   * @param options\n   */\n  private _initInputsFromOptions(options: CanvasWhiteboardOptions): void {\n    if (options) {\n      if (!this._isNullOrUndefined(options.batchUpdateTimeoutDuration)) {\n        this.batchUpdateTimeoutDuration = options.batchUpdateTimeoutDuration;\n      }\n      if (!this._isNullOrUndefined(options.imageUrl)) {\n        this.imageUrl = options.imageUrl;\n      }\n      if (!this._isNullOrUndefined(options.aspectRatio)) {\n        this.aspectRatio = options.aspectRatio;\n      }\n      if (!this._isNullOrUndefined(options.drawButtonClass)) {\n        this.drawButtonClass = options.drawButtonClass;\n      }\n      if (!this._isNullOrUndefined(options.clearButtonClass)) {\n        this.clearButtonClass = options.clearButtonClass;\n      }\n      if (!this._isNullOrUndefined(options.undoButtonClass)) {\n        this.undoButtonClass = options.undoButtonClass;\n      }\n      if (!this._isNullOrUndefined(options.redoButtonClass)) {\n        this.redoButtonClass = options.redoButtonClass;\n      }\n      if (!this._isNullOrUndefined(options.saveDataButtonClass)) {\n        this.saveDataButtonClass = options.saveDataButtonClass;\n      }\n      if (!this._isNullOrUndefined(options.drawButtonText)) {\n        this.drawButtonText = options.drawButtonText;\n      }\n      if (!this._isNullOrUndefined(options.clearButtonText)) {\n        this.clearButtonText = options.clearButtonText;\n      }\n      if (!this._isNullOrUndefined(options.undoButtonText)) {\n        this.undoButtonText = options.undoButtonText;\n      }\n      if (!this._isNullOrUndefined(options.redoButtonText)) {\n        this.redoButtonText = options.redoButtonText;\n      }\n      if (!this._isNullOrUndefined(options.saveDataButtonText)) {\n        this.saveDataButtonText = options.saveDataButtonText;\n      }\n      if (!this._isNullOrUndefined(options.strokeColorPickerText)) {\n        this.strokeColorPickerText = options.strokeColorPickerText;\n      }\n      if (!this._isNullOrUndefined(options.fillColorPickerText)) {\n        this.fillColorPickerText = options.fillColorPickerText;\n      }\n      if (!this._isNullOrUndefined(options.drawButtonEnabled)) {\n        this.drawButtonEnabled = options.drawButtonEnabled;\n      }\n      if (!this._isNullOrUndefined(options.clearButtonEnabled)) {\n        this.clearButtonEnabled = options.clearButtonEnabled;\n      }\n      if (!this._isNullOrUndefined(options.undoButtonEnabled)) {\n        this.undoButtonEnabled = options.undoButtonEnabled;\n      }\n      if (!this._isNullOrUndefined(options.redoButtonEnabled)) {\n        this.redoButtonEnabled = options.redoButtonEnabled;\n      }\n      if (!this._isNullOrUndefined(options.saveDataButtonEnabled)) {\n        this.saveDataButtonEnabled = options.saveDataButtonEnabled;\n      }\n      if (!this._isNullOrUndefined(options.colorPickerEnabled)) {\n        this.colorPickerEnabled = options.colorPickerEnabled;\n      }\n      if (!this._isNullOrUndefined(options.strokeColorPickerEnabled)) {\n        this.strokeColorPickerEnabled = options.strokeColorPickerEnabled;\n      }\n      if (!this._isNullOrUndefined(options.fillColorPickerEnabled)) {\n        this.fillColorPickerEnabled = options.fillColorPickerEnabled;\n      }\n      if (!this._isNullOrUndefined(options.lineWidth)) {\n        this.lineWidth = options.lineWidth;\n      }\n      if (!this._isNullOrUndefined(options.strokeColor)) {\n        this.strokeColor = options.strokeColor;\n      }\n      if (!this._isNullOrUndefined(options.shouldDownloadDrawing)) {\n        this.shouldDownloadDrawing = options.shouldDownloadDrawing;\n      }\n      if (!this._isNullOrUndefined(options.startingColor)) {\n        this.startingColor = options.startingColor;\n      }\n      if (!this._isNullOrUndefined(options.scaleFactor)) {\n        this.scaleFactor = options.scaleFactor;\n      }\n      if (!this._isNullOrUndefined(options.drawingEnabled)) {\n        this.drawingEnabled = options.drawingEnabled;\n      }\n      if (!this._isNullOrUndefined(options.downloadedFileName)) {\n        this.downloadedFileName = options.downloadedFileName;\n      }\n      if (!this._isNullOrUndefined(options.lineJoin)) {\n        this.lineJoin = options.lineJoin;\n      }\n      if (!this._isNullOrUndefined(options.lineCap)) {\n        this.lineCap = options.lineCap;\n      }\n      if (!this._isNullOrUndefined(options.shapeSelectorEnabled)) {\n        this.shapeSelectorEnabled = options.shapeSelectorEnabled;\n      }\n      if (!this._isNullOrUndefined(options.showShapeSelector)) {\n        this.showShapeSelector = options.showShapeSelector;\n      }\n      if (!this._isNullOrUndefined(options.fillColor)) {\n        this.fillColor = options.fillColor;\n      }\n      if (!this._isNullOrUndefined(options.showStrokeColorPicker)) {\n        this.showStrokeColorPicker = options.showStrokeColorPicker;\n      }\n      if (!this._isNullOrUndefined(options.showFillColorPicker)) {\n        this.showFillColorPicker = options.showFillColorPicker;\n      }\n    }\n  }\n\n  private _isNullOrUndefined(property: any): boolean {\n    return property === null || property === undefined;\n  }\n\n  /**\n   * Init global window listeners like resize and keydown\n   */\n  private _initCanvasEventListeners(): void {\n    this.ngZone.runOutsideAngular(() => {\n      this._resizeSubscription = fromEvent(window, 'resize')\n        .pipe(\n          debounceTime(200),\n          distinctUntilChanged()\n        )\n        .subscribe(() => {\n          this.ngZone.run(() => {\n            this._redrawCanvasOnResize();\n          });\n        });\n    });\n\n    window.addEventListener('keydown', this._canvasKeyDown.bind(this), false);\n  }\n\n  /**\n   * Subscribes to new signals in the canvas whiteboard service and executes methods accordingly\n   * Because of circular publishing and subscribing, the canvas methods do not use the service when\n   * local actions are completed (Ex. clicking undo from the button inside this component)\n   */\n  private _initCanvasServiceObservables(): void {\n    this._canvasWhiteboardServiceSubscriptions.push(this.canvasWhiteboardService.canvasDrawSubject$\n      .subscribe(updates => this.drawUpdates(updates)));\n    this._canvasWhiteboardServiceSubscriptions.push(this.canvasWhiteboardService.canvasClearSubject$\n      .subscribe(() => this.clearCanvas()));\n    this._canvasWhiteboardServiceSubscriptions.push(this.canvasWhiteboardService.canvasUndoSubject$\n      .subscribe((updateUUD) => this._undoCanvas(updateUUD)));\n    this._canvasWhiteboardServiceSubscriptions.push(this.canvasWhiteboardService.canvasRedoSubject$\n      .subscribe((updateUUD) => this._redoCanvas(updateUUD)));\n\n    this._registeredShapesSubscription = this.canvasWhiteboardShapeService.registeredShapes$.subscribe((shapes) => {\n      if (!this.selectedShapeConstructor || !this.canvasWhiteboardShapeService.isRegisteredShape(this.selectedShapeConstructor)) {\n        this.selectedShapeConstructor = shapes[0];\n      }\n    });\n  }\n\n  /**\n   * Calculate the canvas width and height from it's parent container width and height (use aspect ratio if needed)\n   */\n  private _calculateCanvasWidthAndHeight(): void {\n    this.context.canvas.width = this.canvas.nativeElement.parentNode.clientWidth;\n    if (this.aspectRatio) {\n      this.context.canvas.height = this.canvas.nativeElement.parentNode.clientWidth * this.aspectRatio;\n    } else {\n      this.context.canvas.height = this.canvas.nativeElement.parentNode.clientHeight;\n    }\n\n    this._incompleteShapesCanvasContext.canvas.width = this.context.canvas.width;\n    this._incompleteShapesCanvasContext.canvas.height = this.context.canvas.height;\n  }\n\n  /**\n   * Load an image and draw it on the canvas (if an image exists)\n   * @param callbackFn A function that is called after the image loading is finished\n   * @return Emits a value when the image has been loaded.\n   */\n  private _loadImage(callbackFn?: any): void {\n    this._canDraw = false;\n\n    // If we already have the image there is no need to acquire it\n    if (this._imageElement) {\n      this._canDraw = true;\n      callbackFn && callbackFn();\n      return;\n    }\n\n    this._imageElement = new Image();\n    this._imageElement.addEventListener('load', () => {\n      this._canDraw = true;\n      callbackFn && callbackFn();\n      this.onImageLoaded.emit(true);\n    });\n    this._imageElement.src = this.imageUrl;\n  }\n\n  /**\n   * Sends a notification after clearing the canvas\n   * This method should only be called from the clear button in this component since it will emit an clear event\n   * If the client calls this method he may create a circular clear action which may cause danger.\n   */\n  clearCanvasLocal(): void {\n    this.clearCanvas();\n    this.onClear.emit(true);\n  }\n\n  /**\n   * Clears all content on the canvas.\n   */\n  clearCanvas(): void {\n    this._removeCanvasData();\n    this._redoStack = [];\n  }\n\n  /**\n   * This method resets the state of the canvas and redraws it.\n   * It calls a callback function after redrawing\n   * @param callbackFn\n   */\n  private _removeCanvasData(callbackFn?: any): void {\n    this._shapesMap = new Map<string, CanvasWhiteboardShape>();\n    this._clientDragging = false;\n    this._updateHistory = [];\n    this._undoStack = [];\n    this._redrawBackground(callbackFn);\n  }\n\n  /**\n   * Clears the canvas and redraws the image if the url exists.\n   * @param callbackFn A function that is called after the background is redrawn\n   * @return Emits a value when the clearing is finished\n   */\n  private _redrawBackground(callbackFn?: any): void {\n    if (this.context) {\n      if (this.imageUrl) {\n        this._loadImage(() => {\n          this.context.save();\n          this._drawImage(this.context, this._imageElement, 0, 0, this.context.canvas.width, this.context.canvas.height, 0.5, 0.5);\n          this.context.restore();\n          this._drawMissingUpdates();\n          callbackFn && callbackFn();\n        });\n      } else {\n        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n        this._drawStartingColor();\n        callbackFn && callbackFn();\n      }\n    }\n  }\n\n  private _drawStartingColor(): void {\n    const previousFillStyle = this.context.fillStyle;\n    this.context.save();\n\n    this.context.fillStyle = this.startingColor;\n    this.context.fillRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n    this.context.fillStyle = previousFillStyle;\n\n    this.context.restore();\n  }\n\n\n  /**\n   * @deprecated Use getDrawingEnabled(): boolean\n   */\n  getShouldDraw(): boolean {\n    return this.getDrawingEnabled();\n  }\n\n  /**\n   * Returns a value of whether the user clicked the draw button on the canvas.\n   */\n  getDrawingEnabled(): boolean {\n    return this.drawingEnabled;\n  }\n\n  /**\n   * Toggles drawing on the canvas. It is called via the draw button on the canvas.\n   */\n  toggleDrawingEnabled(): void {\n    this.drawingEnabled = !this.drawingEnabled;\n  }\n\n  /**\n   * Set if drawing is enabled from the client using the canvas\n   * @param drawingEnabled\n   */\n  setDrawingEnabled(drawingEnabled: boolean): void {\n    this.drawingEnabled = drawingEnabled;\n  }\n\n  /**\n   * @deprecated Please use the changeStrokeColor(newStrokeColor: string): void method\n   */\n  changeColor(newStrokeColor: string): void {\n    this.changeStrokeColor(newStrokeColor);\n  }\n\n  /**\n   * Replaces the drawing color with a new color\n   * The format should be (\"#ffffff\" or \"rgb(r,g,b,a?)\")\n   * This method is public so that anyone can access the canvas and change the stroke color\n   *\n   * @param newStrokeColor The new stroke color\n   */\n  changeStrokeColor(newStrokeColor: string): void {\n    this.strokeColor = newStrokeColor;\n\n    this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n    this.changeDetectorRef.detectChanges();\n  }\n\n  /**\n   * Replaces the fill color with a new color\n   * The format should be (\"#ffffff\" or \"rgb(r,g,b,a?)\")\n   * This method is public so that anyone can access the canvas and change the fill color\n   *\n   * @param newFillColor The new fill color\n   */\n  changeFillColor(newFillColor: string): void {\n    this.fillColor = newFillColor;\n    this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n    this.changeDetectorRef.detectChanges();\n  }\n\n  /**\n   * This method is invoked by the undo button on the canvas screen\n   * It calls the global undo method and emits a notification after undoing.\n   * This method should only be called from the undo button in this component since it will emit an undo event\n   * If the client calls this method he may create a circular undo action which may cause danger.\n   */\n  undoLocal(): void {\n    this.undo((updateUUID) => {\n      this._redoStack.push(updateUUID);\n      this.onUndo.emit(updateUUID);\n    });\n  }\n\n  /**\n   * This methods selects the last uuid prepares it for undoing (making the whole update sequence invisible)\n   * This method can be called if the canvas component is a ViewChild of some other component.\n   * This method will work even if the undo button has been disabled\n   */\n  undo(callbackFn?: (updateUUID: string) => void): void {\n    if (!this._undoStack.length) {\n      return;\n    }\n\n    const updateUUID = this._undoStack.pop();\n    this._undoCanvas(updateUUID);\n    callbackFn && callbackFn(updateUUID);\n  }\n\n  /**\n   * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid invisible\n   * @param updateUUID\n   */\n  private _undoCanvas(updateUUID: string): void {\n    if (this._shapesMap.has(updateUUID)) {\n      const shape = this._shapesMap.get(updateUUID);\n      shape.isVisible = false;\n      this.drawAllShapes();\n    }\n  }\n\n  /**\n   * This method is invoked by the redo button on the canvas screen\n   * It calls the global redo method and emits a notification after redoing\n   * This method should only be called from the redo button in this component since it will emit an redo event\n   * If the client calls this method he may create a circular redo action which may cause danger.\n   */\n  redoLocal(): void {\n    this.redo((updateUUID) => {\n      this._undoStack.push(updateUUID);\n      this.onRedo.emit(updateUUID);\n    });\n  }\n\n  /**\n   * This methods selects the last uuid prepares it for redoing (making the whole update sequence visible)\n   * This method can be called if the canvas component is a ViewChild of some other component.\n   * This method will work even if the redo button has been disabled\n   */\n  redo(callbackFn?: any): void {\n    if (!this._redoStack.length) {\n      return;\n    }\n\n    const updateUUID = this._redoStack.pop();\n    this._redoCanvas(updateUUID);\n    callbackFn && callbackFn(updateUUID);\n  }\n\n  /**\n   * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid visible\n   * @param updateUUID\n   */\n  private _redoCanvas(updateUUID: string): void {\n    if (this._shapesMap.has(updateUUID)) {\n      const shape = this._shapesMap.get(updateUUID);\n      shape.isVisible = true;\n\n      this.drawAllShapes();\n    }\n  }\n\n  /**\n   * Catches the Mouse and Touch events made on the canvas.\n   * If drawing is disabled (If an image exists but it's not loaded, or the user did not click Draw),\n   * this function does nothing.\n   *\n   * If a \"mousedown | touchstart\" event is triggered, dragging will be set to true and an CanvasWhiteboardUpdate object\n   * of type \"start\" will be drawn and then sent as an update to all receiving ends.\n   *\n   * If a \"mousemove | touchmove\" event is triggered and the client is dragging, an CanvasWhiteboardUpdate object\n   * of type \"drag\" will be drawn and then sent as an update to all receiving ends.\n   *\n   * If a \"mouseup, mouseout | touchend, touchcancel\" event is triggered, dragging will be set to false and\n   * an CanvasWhiteboardUpdate object of type \"stop\" will be drawn and then sent as an update to all receiving ends.\n   *\n   */\n  canvasUserEvents(event: any): void {\n    // Ignore all if we didn't click the _draw! button or the image did not load\n    if (!this.drawingEnabled || !this._canDraw) {\n      return;\n    }\n\n    // Ignore mouse move Events if we're not dragging\n    if (!this._clientDragging\n      && (event.type === 'mousemove'\n        || event.type === 'touchmove'\n        || event.type === 'mouseout'\n        || event.type === 'touchcancel'\n        || event.type === 'mouseup'\n        || event.type === 'touchend'\n        || event.type === 'mouseout')) {\n      return;\n    }\n\n    if (event.target == this._incompleteShapesCanvas.nativeElement || event.target == this.canvas.nativeElement) {\n      event.preventDefault();\n    }\n\n    let update: CanvasWhiteboardUpdate;\n    let updateType: number;\n    const eventPosition: CanvasWhiteboardPoint = this._getCanvasEventPosition(event);\n    update = new CanvasWhiteboardUpdate(eventPosition.x, eventPosition.y);\n\n    switch (event.type) {\n      case 'mousedown':\n      case 'touchstart':\n        this._clientDragging = true;\n        this._lastUUID = this._generateUUID();\n        updateType = CanvasWhiteboardUpdateType.START;\n        this._redoStack = [];\n\n        this._addCurrentShapeDataToAnUpdate(update);\n        break;\n      case 'mousemove':\n      case 'touchmove':\n        if (!this._clientDragging) {\n          return;\n        }\n        updateType = CanvasWhiteboardUpdateType.DRAG;\n        break;\n      case 'touchcancel':\n      case 'mouseup':\n      case 'touchend':\n      case 'mouseout':\n        this._clientDragging = false;\n        updateType = CanvasWhiteboardUpdateType.STOP;\n        this._undoStack.push(this._lastUUID);\n        break;\n    }\n\n    update.UUID = this._lastUUID;\n    update.type = updateType;\n\n    this._draw(update);\n    this._prepareToSendUpdate(update);\n  }\n\n  /**\n   * Get the coordinates (x,y) from a given event\n   * If it is a touch event, get the touch positions\n   * If we released the touch, the position will be placed in the changedTouches object\n   * If it is not a touch event, use the original mouse event received\n   * @param eventData\n   */\n  private _getCanvasEventPosition(eventData: any): CanvasWhiteboardPoint {\n    const canvasBoundingRect = this.context.canvas.getBoundingClientRect();\n\n    let hasTouches = (eventData.touches && eventData.touches.length) ? eventData.touches[0] : null;\n    if (!hasTouches) {\n      hasTouches = (eventData.changedTouches && eventData.changedTouches.length) ? eventData.changedTouches[0] : null;\n    }\n\n    const event = hasTouches ? hasTouches : eventData;\n\n    const scaleWidth = canvasBoundingRect.width / this.context.canvas.width;\n    const scaleHeight = canvasBoundingRect.height / this.context.canvas.height;\n\n    let xPosition = (event.clientX - canvasBoundingRect.left);\n    let yPosition = (event.clientY - canvasBoundingRect.top);\n\n    xPosition /= this.scaleFactor ? this.scaleFactor : scaleWidth;\n    yPosition /= this.scaleFactor ? this.scaleFactor : scaleHeight;\n\n    return new CanvasWhiteboardPoint(xPosition / this.context.canvas.width, yPosition / this.context.canvas.height);\n  }\n\n  /**\n   * The update coordinates on the canvas are mapped so that all receiving ends\n   * can reverse the mapping and get the same position as the one that\n   * was drawn on this update.\n   *\n   * @param update The CanvasWhiteboardUpdate object.\n   */\n  private _prepareToSendUpdate(update: CanvasWhiteboardUpdate): void {\n    this._prepareUpdateForBatchDispatch(update);\n  }\n\n\n  /**\n   * Catches the Key Up events made on the canvas.\n   * If the ctrlKey or commandKey(macOS) was held and the keyCode is 90 (z), an undo action will be performed\n   * If the ctrlKey or commandKey(macOS) was held and the keyCode is 89 (y), a redo action will be performed\n   * If the ctrlKey or commandKey(macOS) was held and the keyCode is 83 (s) or 115(S), a save action will be performed\n   *\n   * @param event The event that occurred.\n   */\n  private _canvasKeyDown(event: any): void {\n    if (event.ctrlKey || event.metaKey) {\n      if (event.keyCode === 90 && this.undoButtonEnabled) {\n        event.preventDefault();\n        this.undo();\n      }\n      if (event.keyCode === 89 && this.redoButtonEnabled) {\n        event.preventDefault();\n        this.redo();\n      }\n      if (event.keyCode === 83 || event.keyCode === 115) {\n        event.preventDefault();\n        this.saveLocal();\n      }\n    }\n  }\n\n  /**\n   * On window resize, recalculate the canvas dimensions and redraw the history\n   */\n  private _redrawCanvasOnResize(): void {\n    this._calculateCanvasWidthAndHeight();\n    this._redrawHistory();\n  }\n\n  /**\n   * Redraw the saved history after resetting the canvas state\n   */\n  private _redrawHistory(): void {\n    const updatesToDraw = [].concat(this._updateHistory);\n\n    this._removeCanvasData(() => {\n      updatesToDraw.forEach((update: CanvasWhiteboardUpdate) => {\n        this._draw(update);\n      });\n    });\n  }\n\n  /**\n   * Draws a CanvasWhiteboardUpdate object on the canvas.\n   * The coordinates are first reverse mapped so that they can be drawn in the proper place. The update\n   * is afterwards added to the undoStack so that it can be\n   *\n   * If the CanvasWhiteboardUpdate Type is \"start\", a new \"selectedShape\" is created.\n   * If the CanvasWhiteboardUpdate Type is \"drag\", the shape is taken from the shapesMap and then it's updated.\n   * Afterwards the context is used to draw the shape on the canvas.\n   * This function saves the last X and Y coordinates that were drawn.\n   *\n   * @param update The update object.\n   */\n  private _draw(update: CanvasWhiteboardUpdate): void {\n    this._updateHistory.push(update);\n\n    // map the canvas coordinates to our canvas size since they are scaled.\n    update = Object.assign(new CanvasWhiteboardUpdate(),\n      update,\n      {\n        x: update.x * this.context.canvas.width,\n        y: update.y * this.context.canvas.height\n      });\n\n    if (update.type === CanvasWhiteboardUpdateType.START) {\n      const updateShapeConstructor = this.canvasWhiteboardShapeService.getShapeConstructorFromShapeName(update.selectedShape);\n      const shape = new updateShapeConstructor(\n        new CanvasWhiteboardPoint(update.x, update.y),\n        Object.assign(new CanvasWhiteboardShapeOptions(), update.selectedShapeOptions)\n      );\n      this._incompleteShapesMap.set(update.UUID, shape);\n      this._drawIncompleteShapes();\n    } else if (update.type === CanvasWhiteboardUpdateType.DRAG) {\n      const shape = this._incompleteShapesMap.get(update.UUID);\n      shape && shape.onUpdateReceived(update);\n      this._drawIncompleteShapes();\n    } else if (CanvasWhiteboardUpdateType.STOP) {\n      const shape = this._incompleteShapesMap.get(update.UUID);\n      shape && shape.onStopReceived(update);\n\n      this._shapesMap.set(update.UUID, shape);\n      this._incompleteShapesMap.delete(update.UUID);\n      this._swapCompletedShapeToActualCanvas(shape);\n    }\n  }\n\n  private _drawIncompleteShapes(): void {\n    this._resetIncompleteShapeCanvas();\n    this._incompleteShapesMap.forEach((shape) => {\n      if (shape.isVisible) {\n        shape.draw(this._incompleteShapesCanvasContext);\n      }\n    });\n  }\n\n  private _swapCompletedShapeToActualCanvas(shape: CanvasWhiteboardShape): void {\n    this._drawIncompleteShapes();\n    if (shape.isVisible) {\n      shape.draw(this.context);\n    }\n  }\n\n  private _resetIncompleteShapeCanvas(): void {\n    this._incompleteShapesCanvasContext.clearRect(0, 0, this._incompleteShapesCanvasContext.canvas.width,\n      this._incompleteShapesCanvasContext.canvas.height);\n    this._incompleteShapesCanvasContext.fillStyle = 'transparent';\n    this._incompleteShapesCanvasContext.fillRect(0, 0, this._incompleteShapesCanvasContext.canvas.width,\n      this._incompleteShapesCanvasContext.canvas.height);\n  }\n\n  /**\n   * Delete everything from the screen, redraw the background, and then redraw all the shapes from the shapesMap\n   */\n  drawAllShapes(): void {\n    this._redrawBackground(() => {\n      this._shapesMap.forEach((shape: CanvasWhiteboardShape) => {\n        if (shape.isVisible) {\n          shape.draw(this.context);\n        }\n      });\n    });\n  }\n\n  private _addCurrentShapeDataToAnUpdate(update: CanvasWhiteboardUpdate): void {\n    if (!update.selectedShape) {\n      update.selectedShape = (new this.selectedShapeConstructor).getShapeName();\n    }\n\n    if (!update.selectedShapeOptions) {\n      // Make a deep copy since we don't want some Shape implementation to change something by accident\n      update.selectedShapeOptions = Object.assign(new CanvasWhiteboardShapeOptions(),\n        this.generateShapePreviewOptions(), {lineWidth: this.lineWidth});\n    }\n  }\n\n  generateShapePreviewOptions(): CanvasWhiteboardShapeOptions {\n    return Object.assign(new CanvasWhiteboardShapeOptions(),\n      {\n        shouldFillShape: !!this.fillColor,\n        fillStyle: this.fillColor,\n        strokeStyle: this.strokeColor,\n        lineWidth: 2,\n        lineJoin: this.lineJoin,\n        lineCap: this.lineCap\n      });\n  }\n\n  /**\n   * Sends the update to all receiving ends as an Event emit. This is done as a batch operation (meaning\n   * multiple updates are sent at the same time). If this method is called, after 100 ms all updates\n   * that were made at that time will be packed up together and sent to the receiver.\n   *\n   * @param update The update object.\n   * @return Emits an Array of Updates when the batch.\n   */\n  private _prepareUpdateForBatchDispatch(update: CanvasWhiteboardUpdate): void {\n    this._batchUpdates.push(cloneDeep(update));\n    if (!this._updateTimeout) {\n      this._updateTimeout = setTimeout(() => {\n        this.onBatchUpdate.emit(this._batchUpdates);\n        this._batchUpdates = [];\n        this._updateTimeout = null;\n      }, this.batchUpdateTimeoutDuration);\n    }\n  }\n\n  /**\n   * Draws an Array of Updates on the canvas.\n   *\n   * @param updates The array with Updates.\n   */\n  drawUpdates(updates: CanvasWhiteboardUpdate[]): void {\n    if (this._canDraw) {\n      this._drawMissingUpdates();\n      updates.forEach((update: CanvasWhiteboardUpdate) => {\n        this._draw(update);\n      });\n    } else {\n      this._updatesNotDrawn = this._updatesNotDrawn.concat(updates);\n    }\n  }\n\n  /**\n   * Draw any missing updates that were received before the image was loaded\n   */\n  private _drawMissingUpdates(): void {\n    if (this._updatesNotDrawn.length > 0) {\n      const updatesToDraw = this._updatesNotDrawn;\n      this._updatesNotDrawn = [];\n\n      updatesToDraw.forEach((update: CanvasWhiteboardUpdate) => {\n        this._draw(update);\n      });\n    }\n  }\n\n  /**\n   * Draws an image on the canvas\n   *\n   * @param context The context used to draw the image on the canvas.\n   * @param image The image to draw.\n   * @param x The X coordinate for the starting draw position.\n   * @param y The Y coordinate for the starting draw position.\n   * @param width The width of the image that will be drawn.\n   * @param height The height of the image that will be drawn.\n   * @param offsetX The offsetX if the image size is larger than the canvas (aspect Ratio)\n   * @param offsetY The offsetY if the image size is larger than the canvas (aspect Ratio)\n   */\n  private _drawImage(context: any, image: any, x: number, y: number, width: number, height: number, offsetX: number, offsetY: number): void {\n    if (arguments.length === 2) {\n      x = y = 0;\n      width = context.canvas.width;\n      height = context.canvas.height;\n    }\n\n    offsetX = typeof offsetX === 'number' ? offsetX : 0.5;\n    offsetY = typeof offsetY === 'number' ? offsetY : 0.5;\n\n    if (offsetX < 0) {\n      offsetX = 0;\n    }\n    if (offsetY < 0) {\n      offsetY = 0;\n    }\n    if (offsetX > 1) {\n      offsetX = 1;\n    }\n    if (offsetY > 1) {\n      offsetY = 1;\n    }\n\n    const imageWidth = image.width;\n    const imageHeight = image.height;\n    const radius = Math.min(width / imageWidth, height / imageHeight);\n    let newWidth = imageWidth * radius;\n    let newHeight = imageHeight * radius;\n    let finalDrawX: any;\n    let finalDrawY: any;\n    let finalDrawWidth: any;\n    let finalDrawHeight: any;\n    let aspectRatio = 1;\n\n    // decide which gap to fill\n    if (newWidth < width) {\n      aspectRatio = width / newWidth;\n    }\n    if (Math.abs(aspectRatio - 1) < 1e-14 && newHeight < height) {\n      aspectRatio = height / newHeight;\n    }\n    newWidth *= aspectRatio;\n    newHeight *= aspectRatio;\n\n    // calculate source rectangle\n    finalDrawWidth = imageWidth / (newWidth / width);\n    finalDrawHeight = imageHeight / (newHeight / height);\n\n    finalDrawX = (imageWidth - finalDrawWidth) * offsetX;\n    finalDrawY = (imageHeight - finalDrawHeight) * offsetY;\n\n    // make sure the source rectangle is valid\n    if (finalDrawX < 0) {\n      finalDrawX = 0;\n    }\n    if (finalDrawY < 0) {\n      finalDrawY = 0;\n    }\n    if (finalDrawWidth > imageWidth) {\n      finalDrawWidth = imageWidth;\n    }\n    if (finalDrawHeight > imageHeight) {\n      finalDrawHeight = imageHeight;\n    }\n\n    // fill the image in destination rectangle\n    context.drawImage(image, finalDrawX, finalDrawY, finalDrawWidth, finalDrawHeight, x, y, width, height);\n  }\n\n  /**\n   * The HTMLCanvasElement.toDataURL() method returns a data URI containing a representation of the image in the format specified by the type parameter (defaults to PNG).\n   * The returned image is in a resolution of 96 dpi.\n   * If the height or width of the canvas is 0, the string \"data:,\" is returned.\n   * If the requested type is not image/png, but the returned value starts with data:image/png, then the requested type is not supported.\n   * Chrome also supports the image/webp type.\n   *\n   * @param returnedDataType A DOMString indicating the image format. The default format type is image/png.\n   * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.\n   If this argument is anything else, the default value for image quality is used. The default value is 0.92. Other arguments are ignored.\n   */\n  generateCanvasDataUrl(returnedDataType: string = 'image/png', returnedDataQuality: number = 1): string {\n    return this.context.canvas.toDataURL(returnedDataType, returnedDataQuality);\n  }\n\n  /**\n   * Generate a Blob object representing the content drawn on the canvas.\n   * This file may be cached on the disk or stored in memory at the discretion of the user agent.\n   * If type is not specified, the image type is image/png. The created image is in a resolution of 96dpi.\n   * The third argument is used with image/jpeg images to specify the quality of the output.\n   *\n   * @param callbackFn The function that should be executed when the blob is created. Should accept a parameter Blob (for the result).\n   * @param returnedDataType A DOMString indicating the image format. The default type is image/png.\n   * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.\n   If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n   */\n  generateCanvasBlob(callbackFn: any, returnedDataType: string = 'image/png', returnedDataQuality: number = 1): void {\n    let toBlobMethod: Function;\n\n    if (typeof this.context.canvas.toBlob !== 'undefined') {\n      toBlobMethod = this.context.canvas.toBlob.bind(this.context.canvas);\n    } else if (typeof (this.context.canvas as any).msToBlob !== 'undefined') {\n      // For IE\n      toBlobMethod = (callback) => {\n        callback && callback((this.context.canvas as any).msToBlob());\n      };\n    }\n\n    toBlobMethod && toBlobMethod((blob: Blob) => {\n      callbackFn && callbackFn(blob, returnedDataType);\n    }, returnedDataType, returnedDataQuality);\n  }\n\n  /**\n   * Generate a canvas image representation and download it locally\n   * The name of the image is canvas_drawing_ + the current local Date and Time the image was created\n   * Methods for standalone creation of the images in this method are left here for backwards compatibility\n   *\n   * @param returnedDataType A DOMString indicating the image format. The default type is image/png.\n   * @param downloadData? The created string or Blob (IE).\n   * @param customFileName? The name of the file that should be downloaded\n   */\n  downloadCanvasImage(returnedDataType: string = 'image/png', downloadData?: string | Blob, customFileName?: string): void {\n    if (window.navigator.msSaveOrOpenBlob === undefined) {\n      const downloadLink = document.createElement('a');\n      downloadLink.setAttribute('href', downloadData ? downloadData as string : this.generateCanvasDataUrl(returnedDataType));\n\n      const fileName = customFileName ? customFileName\n        : (this.downloadedFileName ? this.downloadedFileName : 'canvas_drawing_' + new Date().valueOf());\n\n      downloadLink.setAttribute('download', fileName + this._generateDataTypeString(returnedDataType));\n      document.body.appendChild(downloadLink);\n      downloadLink.click();\n      document.body.removeChild(downloadLink);\n    } else {\n      // IE-specific code\n      if (downloadData) {\n        this._saveCanvasBlob(downloadData as Blob, returnedDataType);\n      } else {\n        this.generateCanvasBlob(this._saveCanvasBlob.bind(this), returnedDataType);\n      }\n    }\n  }\n\n  /**\n   * Save the canvas blob (IE) locally\n   * @param blob\n   * @param returnedDataType\n   */\n  private _saveCanvasBlob(blob: Blob, returnedDataType: string = 'image/png'): void {\n    window.navigator.msSaveOrOpenBlob(blob, 'canvas_drawing_' +\n      new Date().valueOf() + this._generateDataTypeString(returnedDataType));\n  }\n\n  /**\n   * This method generates a canvas url string or a canvas blob with the presented data type\n   * A callback function is then invoked since the blob creation must be done via a callback\n   *\n   * @param callback\n   * @param returnedDataType\n   * @param returnedDataQuality\n   */\n  generateCanvasData(callback: any, returnedDataType: string = 'image/png', returnedDataQuality: number = 1): void {\n    if (window.navigator.msSaveOrOpenBlob === undefined) {\n      callback && callback(this.generateCanvasDataUrl(returnedDataType, returnedDataQuality));\n    } else {\n      this.generateCanvasBlob(callback, returnedDataType, returnedDataQuality);\n    }\n  }\n\n  /**\n   * Local method to invoke saving of the canvas data when clicked on the canvas Save button\n   * This method will emit the generated data with the specified Event Emitter\n   *\n   * @param returnedDataType\n   */\n  saveLocal(returnedDataType: string = 'image/png'): void {\n    this.generateCanvasData((generatedData: string | Blob) => {\n      this.onSave.emit(generatedData);\n\n      if (this.shouldDownloadDrawing) {\n        this.downloadCanvasImage(returnedDataType, generatedData);\n      }\n    });\n  }\n\n  private _generateDataTypeString(returnedDataType: string): string {\n    if (returnedDataType) {\n      return '.' + returnedDataType.split('/')[1];\n    }\n\n    return '';\n  }\n\n  /**\n   * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.\n   * If no value is supplied (null/undefined) the current value will be negated and used.\n   * @param value\n   */\n  toggleStrokeColorPicker(value: boolean): void {\n    this.showStrokeColorPicker = !this._isNullOrUndefined(value) ? value : !this.showStrokeColorPicker;\n  }\n\n  /**\n   * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.\n   * If no value is supplied (null/undefined) the current value will be negated and used.\n   * @param value\n   */\n  toggleFillColorPicker(value: boolean): void {\n    this.showFillColorPicker = !this._isNullOrUndefined(value) ? value : !this.showFillColorPicker;\n  }\n\n  /**\n   * Toggles the shape selector window, delegating the showShapeSelector Input to the CanvasWhiteboardShapeSelectorComponent.\n   * If no value is supplied (null/undefined) the current value will be negated and used.\n   * @param value\n   */\n  toggleShapeSelector(value: boolean): void {\n    this.showShapeSelector = !this._isNullOrUndefined(value) ? value : !this.showShapeSelector;\n  }\n\n  selectShape(newShapeBlueprint: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): void {\n    this.selectedShapeConstructor = newShapeBlueprint;\n  }\n\n  /**\n   * Returns a deep copy of the current drawing history for the canvas.\n   * The deep copy is returned because we don't want anyone to mutate the current history\n   */\n  getDrawingHistory(): CanvasWhiteboardUpdate[] {\n    return cloneDeep(this._updateHistory);\n  }\n\n  /**\n   * Unsubscribe from a given subscription if it is active\n   * @param subscription\n   */\n  private _unsubscribe(subscription: Subscription): void {\n    if (subscription) {\n      subscription.unsubscribe();\n    }\n  }\n\n  private _generateUUID(): string {\n    return this._random4() + this._random4() + '-' + this._random4() + '-' + this._random4() + '-' +\n      this._random4() + '-' + this._random4() + this._random4() + this._random4();\n  }\n\n  private _random4(): string {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n\n  /**\n   * Unsubscribe from the service observables\n   */\n  ngOnDestroy(): void {\n    this._unsubscribe(this._resizeSubscription);\n    this._unsubscribe(this._registeredShapesSubscription);\n    this._canvasWhiteboardServiceSubscriptions.forEach(subscription => this._unsubscribe(subscription));\n  }\n}\n","import {\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  Output\n} from '@angular/core';\nimport { CanvasWhiteboardShapeService, INewCanvasWhiteboardShape } from './canvas-whiteboard-shape.service';\nimport { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\nimport { Observable } from 'rxjs';\n\n@Component({\n  selector: 'canvas-whiteboard-shape-selector',\n  host: {\n    '(document:mousedown)': 'closeOnExternalClick($event)',\n    '(document:touchstart)': 'closeOnExternalClick($event)'\n  },\n  template: `\n    <div *ngIf=\"!showShapeSelector\" (click)=\"toggleShapeSelector($event)\"\n         class=\"canvas-whiteboard-shape-selector-selected-preview\">\n      <canvas-whiteboard-shape-preview [shapeConstructor]=\"selectedShapeConstructor\"\n                                       [shapeOptions]=\"shapeOptions\"></canvas-whiteboard-shape-preview>\n    </div>\n    <div class=\"canvas-whiteboard-shape-selector-wrapper\" *ngIf=\"showShapeSelector\">\n      <canvas-whiteboard-shape-preview *ngFor=\"let shapeConstructor of registeredShapes$ | async\"\n                                       [shapeConstructor]=\"shapeConstructor\"\n                                       [shapeOptions]=\"shapeOptions\"\n                                       (click)=\"selectShape(shapeConstructor)\"></canvas-whiteboard-shape-preview>\n    </div>\n  `,\n  styles: [`\n    .canvas-whiteboard-shape-selector-selected-preview {\n      vertical-align: bottom;\n      display: inline-block;\n    }\n\n    .canvas-whiteboard-shape-selector-wrapper {\n      display: block;\n      padding: 4px;\n      border: 1px solid #afafaf;\n    }\n\n    @media (min-width: 401px) {\n      .canvas-whiteboard-shape-selector-wrapper {\n      }\n    }\n  `]\n})\nexport class CanvasWhiteboardShapeSelectorComponent {\n  @Input() readonly showShapeSelector: boolean = false;\n  @Input() readonly selectedShapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n  @Input() readonly shapeOptions: CanvasWhiteboardShapeOptions;\n\n  @Output() onToggleShapeSelector = new EventEmitter<boolean>();\n  @Output() onShapeSelected = new EventEmitter<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>();\n\n  registeredShapes$: Observable<INewCanvasWhiteboardShape<CanvasWhiteboardShape>[]>;\n\n  constructor(private elementRef: ElementRef,\n              private canvasWhiteboardShapeService: CanvasWhiteboardShapeService) {\n    this.registeredShapes$ = this.canvasWhiteboardShapeService.registeredShapes$;\n  }\n\n  selectShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>): void {\n    this.onShapeSelected.emit(shape);\n    this.toggleShapeSelector(null);\n  }\n\n  closeOnExternalClick(event): void {\n    if (!this.elementRef.nativeElement.contains(event.target) && this.showShapeSelector) {\n      this.onToggleShapeSelector.emit(false);\n    }\n  }\n\n  toggleShapeSelector(event: Event): void {\n    if (event) {\n      event.preventDefault();\n    }\n\n    this.onToggleShapeSelector.emit(!this.showShapeSelector);\n  }\n}\n","import {\n  Component,\n  Output,\n  EventEmitter, OnInit, ViewChild, ElementRef, Input\n} from '@angular/core';\n\n@Component({\n  selector: 'canvas-whiteboard-colorpicker',\n  host: {\n    '(document:mousedown)': 'closeOnExternalClick($event)',\n    '(document:touchstart)': 'closeOnExternalClick($event)'\n  },\n  template: `\n    <div [hidden]=\"showColorPicker\" class=\"canvas-whiteboard-colorpicker-input\"\n         (click)=\"toggleColorPicker($event)\">\n      <div class=\"selected-color-type-wrapper\">{{previewText}}</div>\n      <div class=\"selected-color-preview\" [style.background]=\"selectedColor\"></div>\n    </div>\n    <div [hidden]=\"!showColorPicker\" class=\"canvas-whiteboard-colorpicker-wrapper\">\n      <div (click)=\"selectColor('transparent')\" class=\"transparent-color\">Transparent</div>\n      <canvas #canvaswhiteboardcolorpicker class=\"canvas-whiteboard-colorpicker\" width=\"284\" height=\"155\"\n              (click)=\"selectColor(determineColorFromCanvas($event))\"></canvas>\n    </div>\n  `,\n  styles: [`\n    .selected-color-preview {\n      width: 100%;\n      height: 20%;\n      position: absolute;\n      bottom: 0;\n      left: 0;\n    }\n\n    .selected-color-type-wrapper {\n      display: inline-block;\n      height: 100%;\n      width: 100%;\n      text-align: center;\n      font-size: 14px;\n      color: #000;\n    }\n\n    .transparent-color {\n      font-size: 14px;\n    }\n\n    .canvas-whiteboard-colorpicker-wrapper {\n      border: 1px solid #afafaf;\n      color: #000;\n    }\n\n    @media (min-width: 401px) {\n      .canvas-whiteboard-colorpicker-wrapper {\n        position: absolute;\n      }\n    }\n\n    .canvas-whiteboard-colorpicker-input {\n      display: inline-block;\n      position: relative;\n      width: 44px;\n      height: 44px;\n      margin: 5px;\n      cursor: pointer;\n      color: #000;\n    }\n  `]\n})\nexport class CanvasWhiteboardColorPickerComponent implements OnInit {\n\n  @Input() previewText: string;\n  @Input() readonly selectedColor: string = 'rgba(0,0,0,1)';\n  @ViewChild('canvaswhiteboardcolorpicker', {static: true}) canvas: ElementRef;\n\n  @Input() readonly showColorPicker: boolean = false;\n  private _context: CanvasRenderingContext2D;\n\n  @Output() onToggleColorPicker = new EventEmitter<boolean>();\n  @Output() onColorSelected = new EventEmitter<string>();\n  @Output() onSecondaryColorSelected = new EventEmitter<string>();\n\n  constructor(private elementRef: ElementRef) {\n  }\n\n  /**\n   * Initialize the canvas drawing context. If we have an aspect ratio set up, the canvas will resize\n   * according to the aspect ratio.\n   */\n  ngOnInit(): void {\n    this._context = this.canvas.nativeElement.getContext('2d');\n    this.createColorPalette();\n  }\n\n  createColorPalette(): void {\n    let gradient = this._context.createLinearGradient(0, 0, this._context.canvas.width, 0);\n    gradient.addColorStop(0, 'rgb(255, 0, 0)');\n    gradient.addColorStop(0.15, 'rgb(255, 0, 255)');\n    gradient.addColorStop(0.33, 'rgb(0, 0, 255)');\n    gradient.addColorStop(0.49, 'rgb(0, 255, 255)');\n    gradient.addColorStop(0.67, 'rgb(0, 255, 0)');\n    gradient.addColorStop(0.84, 'rgb(255, 255, 0)');\n    gradient.addColorStop(1, 'rgb(255, 0, 0)');\n    this._context.fillStyle = gradient;\n    this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n    gradient = this._context.createLinearGradient(0, 0, 0, this._context.canvas.height);\n    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\n    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');\n    gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');\n    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');\n    this._context.fillStyle = gradient;\n    this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n  }\n\n  closeOnExternalClick(event): void {\n    if (!this.elementRef.nativeElement.contains(event.target) && this.showColorPicker) {\n      this.onToggleColorPicker.emit(false);\n    }\n  }\n\n  toggleColorPicker(event: Event): void {\n    if (event) {\n      event.preventDefault();\n    }\n\n    this.onToggleColorPicker.emit(!this.showColorPicker);\n  }\n\n  determineColorFromCanvas(event: any): string {\n    const canvasRect = this._context.canvas.getBoundingClientRect();\n    const imageData = this._context.getImageData(event.clientX - canvasRect.left,\n      event.clientY - canvasRect.top, 1, 1);\n\n    return `rgba(${imageData.data[0]}, ${imageData.data[1]}, ${imageData.data[2]}, ${imageData.data[3]})`;\n  }\n\n  selectColor(color: string): void {\n    this.onColorSelected.emit(color);\n    this.toggleColorPicker(null);\n  }\n}\n","import {\n  Component,\n  ElementRef,\n  Input,\n  ViewChild,\n  AfterViewInit,\n  OnChanges,\n  SimpleChanges\n} from '@angular/core';\nimport { INewCanvasWhiteboardShape } from './canvas-whiteboard-shape.service';\nimport { CanvasWhiteboardShape } from './canvas-whiteboard-shape';\nimport { CanvasWhiteboardPoint } from '../canvas-whiteboard-point.model';\nimport { CanvasWhiteboardShapeOptions } from './canvas-whiteboard-shape-options';\n\n@Component({\n  selector: 'canvas-whiteboard-shape-preview',\n  template: `\n    <canvas #canvasWhiteboardShapePreview width=\"50px\" height=\"50px\"\n            class=\"canvas-whiteboard-shape-preview-canvas\"></canvas>\n  `,\n  styles: [`\n    .canvas-whiteboard-shape-preview-canvas {\n      cursor: pointer;\n    }\n  `]\n})\nexport class CanvasWhiteboardShapePreviewComponent implements AfterViewInit, OnChanges {\n  @Input() readonly shapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n  @Input() readonly shapeOptions: CanvasWhiteboardShapeOptions;\n\n  @ViewChild('canvasWhiteboardShapePreview') canvas: ElementRef;\n\n  ngAfterViewInit(): void {\n    this.drawShapePreview();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.shapeConstructor || changes.shapeOptions) {\n      this.drawShapePreview();\n    }\n  }\n\n  drawShapePreview(): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    const context: CanvasRenderingContext2D = this.canvas.nativeElement.getContext('2d');\n    context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n\n    const concreteShape = new this.shapeConstructor(\n      new CanvasWhiteboardPoint(0, 0),\n      Object.assign(new CanvasWhiteboardShapeOptions(), this.shapeOptions)\n    );\n\n    concreteShape.drawPreview(context);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CanvasWhiteboardComponent } from './canvas-whiteboard.component';\nimport { CommonModule } from '@angular/common';\nimport { CanvasWhiteboardColorPickerComponent } from './canvas-whiteboard-colorpicker.component';\nimport { CanvasWhiteboardShapeSelectorComponent } from './shapes/canvas-whiteboard-shape-selector.component';\nimport { CanvasWhiteboardShapePreviewComponent } from './shapes/canvas-whiteboard-shape-preview.component';\nimport { CanvasWhiteboardService } from './canvas-whiteboard.service';\nimport { CanvasWhiteboardShapeService } from './shapes/canvas-whiteboard-shape.service';\n\n@NgModule({\n  declarations: [\n    CanvasWhiteboardComponent,\n    CanvasWhiteboardColorPickerComponent,\n    CanvasWhiteboardShapeSelectorComponent,\n    CanvasWhiteboardShapePreviewComponent\n  ],\n  imports: [\n    CommonModule\n  ],\n  providers: [\n    CanvasWhiteboardService,\n    CanvasWhiteboardShapeService\n  ],\n  exports: [CanvasWhiteboardComponent]\n})\nexport class CanvasWhiteboardModule {\n\n}\n"]}